{
  "Summary": {
    "Name": "Min Max Stack Construction",
    "Category": "Stacks",
    "Difficulty": 2,
    "Available": true,
    "Metadata": {
      "date": "2018-10-20T00:00:00Z",
      "number": 152,
      "timeOne": 0,
      "timeTwo": 1060,
      "url": "https://player.vimeo.com/video/291687370"
    }
  },
  "Prompt": "",
  "Hints": "You should be able to push values on, pop values off, and peek at values on top of the stack at any time and in constant time, using constant space. What data structure maintains order and would allow you to do this?\nYou should be able to get the minimum and maximum values in the stack at any time and in constant time, using constant space. What data structure would allow you to do this?\nSince the minimum and maximum values in the stack can change with every push and pop, you will likely need to keep track of all the mins and maxes at every value in the stack.\n",
  "SpaceTime": "All methods: O(1) time | O(1) space\n",
  "PromptHTML": "<p>\n  Write a <span>MinMaxStack</span> class for a Min Max Stack. The class should\n  support:\n</p>\n<ul>\n  <li>- Pushing and popping values on and off the stack.</li>\n  <li>- Peeking at the value at the top of the stack.</li>\n  <li>\n    - Getting both the minimum and the maximum values in the stack at any given\n    point in time.\n  </li>\n</ul>\n<p>\n  All class methods, when considered independently, should run in constant time\n  and with constant space.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class=\"CodeEditor-promptComment\">// All operations below are performed sequentially.</span>\n<span class=\"CodeEditor-promptParameter\">MinMaxStack</span>(): - <span class=\"CodeEditor-promptComment\">// instantiate a MinMaxStack</span>\n<span class=\"CodeEditor-promptParameter\">push</span>(5): -\n<span class=\"CodeEditor-promptParameter\">getMin</span>(): 5\n<span class=\"CodeEditor-promptParameter\">getMax</span>(): 5\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 5\n<span class=\"CodeEditor-promptParameter\">push</span>(7): -\n<span class=\"CodeEditor-promptParameter\">getMin</span>(): 5\n<span class=\"CodeEditor-promptParameter\">getMax</span>(): 7\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 7\n<span class=\"CodeEditor-promptParameter\">push</span>(2): -\n<span class=\"CodeEditor-promptParameter\">getMin</span>(): 2\n<span class=\"CodeEditor-promptParameter\">getMax</span>(): 7\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 2\n<span class=\"CodeEditor-promptParameter\">pop</span>(): 2\n<span class=\"CodeEditor-promptParameter\">pop</span>(): 7\n<span class=\"CodeEditor-promptParameter\">getMin</span>(): 5\n<span class=\"CodeEditor-promptParameter\">getMax</span>(): 5\n<span class=\"CodeEditor-promptParameter\">peek</span>(): 5\n</pre>\n",
  "Notes": "",
  "IsLongOutput": false,
  "Visualization": {
    "inputType": null,
    "outputType": null
  },
  "CustomInputLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "CustomInputVars": [
    {
      "Name": "classMethodsToCall",
      "Example": [
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            7
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        }
      ],
      "Schema": {
        "description": "These methods will be called in the order that they appear in below\non a <span>MinMaxStack</span> and with their respective arguments.\n",
        "items": {
          "properties": {
            "arguments": {
              "maxItems": 1,
              "type": "array"
            },
            "method": {
              "enum": [
                "getMax",
                "getMin",
                "peek",
                "pop",
                "push"
              ],
              "type": "string"
            }
          },
          "required": [
            "method",
            "arguments"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  ],
  "Resources": {
    "cpp": {
      "Language": "cpp",
      "StartingCode": "using namespace std;\n\n// Feel free to add new properties and methods to the class.\nclass MinMaxStack {\npublic:\n  int peek() {\n    // Write your code here.\n    return -1;\n  }\n\n  int pop() {\n    // Write your code here.\n    return -1;\n  }\n\n  void push(int number) {\n    // Write your code here.\n  }\n\n  int getMin() {\n    // Write your code here.\n    return -1;\n  }\n\n  int getMax() {\n    // Write your code here.\n    return -1;\n  }\n};\n",
      "StartingTest": "#define testMinMaxPeek(min, max, peekValue, stack)                             \\\n  {                                                                            \\\n    assert(stack.getMin() == min);                                             \\\n    assert(stack.getMax() == max);                                             \\\n    assert(stack.peek() == peekValue);                                         \\\n  }\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n\n    RunTest(\"Test Case 1\", []() {\n      MinMaxStack stack;\n      stack.push(2);\n      testMinMaxPeek(2, 2, 2, stack);\n      stack.push(7);\n      testMinMaxPeek(2, 7, 7, stack);\n      stack.push(1);\n      testMinMaxPeek(1, 7, 1, stack);\n      stack.push(8);\n      testMinMaxPeek(1, 8, 8, stack);\n      stack.push(3);\n      testMinMaxPeek(1, 8, 3, stack);\n      stack.push(9);\n      testMinMaxPeek(1, 9, 9, stack);\n      assert(stack.pop() == 9);\n      testMinMaxPeek(1, 8, 3, stack);\n      assert(stack.pop() == 3);\n      testMinMaxPeek(1, 8, 8, stack);\n      assert(stack.pop() == 8);\n      testMinMaxPeek(1, 7, 1, stack);\n      assert(stack.pop() == 1);\n      testMinMaxPeek(2, 7, 7, stack);\n      assert(stack.pop() == 7);\n      testMinMaxPeek(2, 2, 2, stack);\n      assert(stack.pop() == 2);\n    });\n\n    RunTest(\"Test Case 2\", []() {\n      MinMaxStack stack;\n      stack.push(5);\n      testMinMaxPeek(5, 5, 5, stack);\n      stack.push(5);\n      testMinMaxPeek(5, 5, 5, stack);\n      stack.push(5);\n      testMinMaxPeek(5, 5, 5, stack);\n      stack.push(5);\n      testMinMaxPeek(5, 5, 5, stack);\n      stack.push(8);\n      testMinMaxPeek(5, 8, 8, stack);\n      stack.push(8);\n      testMinMaxPeek(5, 8, 8, stack);\n      stack.push(0);\n      testMinMaxPeek(0, 8, 0, stack);\n      stack.push(8);\n      testMinMaxPeek(0, 8, 8, stack);\n      stack.push(9);\n      testMinMaxPeek(0, 9, 9, stack);\n      stack.push(5);\n      testMinMaxPeek(0, 9, 5, stack);\n      assert(stack.pop() == 5);\n      testMinMaxPeek(0, 9, 9, stack);\n      assert(stack.pop() == 9);\n      testMinMaxPeek(0, 8, 8, stack);\n      assert(stack.pop() == 8);\n      testMinMaxPeek(0, 8, 0, stack);\n      assert(stack.pop() == 0);\n      testMinMaxPeek(5, 8, 8, stack);\n      assert(stack.pop() == 8);\n      testMinMaxPeek(5, 8, 8, stack);\n      assert(stack.pop() == 8);\n      testMinMaxPeek(5, 5, 5, stack);\n      assert(stack.pop() == 5);\n      testMinMaxPeek(5, 5, 5, stack);\n      assert(stack.pop() == 5);\n      testMinMaxPeek(5, 5, 5, stack);\n      assert(stack.pop() == 5);\n      testMinMaxPeek(5, 5, 5, stack);\n      assert(stack.pop() == 5);\n    });\n\n    RunTest(\"Test Case 3\", []() {\n      MinMaxStack stack;\n      stack.push(2);\n      testMinMaxPeek(2, 2, 2, stack);\n      stack.push(0);\n      testMinMaxPeek(0, 2, 0, stack);\n      stack.push(5);\n      testMinMaxPeek(0, 5, 5, stack);\n      stack.push(4);\n      testMinMaxPeek(0, 5, 4, stack);\n      assert(stack.pop() == 4);\n      testMinMaxPeek(0, 5, 5, stack);\n      assert(stack.pop() == 5);\n      testMinMaxPeek(0, 2, 0, stack);\n      stack.push(4);\n      testMinMaxPeek(0, 4, 4, stack);\n      stack.push(11);\n      testMinMaxPeek(0, 11, 11, stack);\n      stack.push(-11);\n      testMinMaxPeek(-11, 11, -11, stack);\n      assert(stack.pop() == -11);\n      testMinMaxPeek(0, 11, 11, stack);\n      assert(stack.pop() == 11);\n      testMinMaxPeek(0, 4, 4, stack);\n      assert(stack.pop() == 4);\n      testMinMaxPeek(0, 2, 0, stack);\n      assert(stack.pop() == 0);\n      testMinMaxPeek(2, 2, 2, stack);\n      assert(stack.pop() == 2);\n      stack.push(6);\n      testMinMaxPeek(6, 6, 6, stack);\n      assert(stack.pop() == 6);\n    });\n  }\n};\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#define testMinMaxPeek(min, max, peekValue, stack)                             \\\n  {                                                                            \\\n    assert(stack.getMin() == min);                                             \\\n    assert(stack.getMax() == max);                                             \\\n    assert(stack.peek() == peekValue);                                         \\\n  }\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      MinMaxStack stack;\n      stack.push(5);\n      testMinMaxPeek(5, 5, 5, stack);\n      stack.push(7);\n      testMinMaxPeek(5, 7, 7, stack);\n      stack.push(2);\n      testMinMaxPeek(2, 7, 2, stack);\n      assert(stack.pop() == 2);\n      assert(stack.pop() == 7);\n      testMinMaxPeek(5, 5, 5, stack);\n    });\n  }\n};\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass MinMaxStack {\npublic:\n  vector<unordered_map<string, int>> minMaxStack = {};\n  vector<int> stack = {};\n\n  // O(1) time | O(1) space\n  int peek() { return stack[stack.size() - 1]; }\n\n  // O(1) time | O(1) space\n  int pop() {\n    minMaxStack.pop_back();\n    int result = stack[stack.size() - 1];\n    stack.pop_back();\n    return result;\n  }\n\n  // O(1) time | O(1) space\n  void push(int number) {\n    unordered_map<string, int> newMinMax = {{\"min\", number}, {\"max\", number}};\n    if (minMaxStack.size()) {\n      unordered_map<string, int> lastMinMax =\n          minMaxStack[minMaxStack.size() - 1];\n      newMinMax[\"min\"] = min(lastMinMax[\"min\"], number);\n      newMinMax[\"max\"] = max(lastMinMax[\"max\"], number);\n    }\n    minMaxStack.push_back(newMinMax);\n    stack.push_back(number);\n  }\n\n  // O(1) time | O(1) space\n  int getMin() { return minMaxStack[minMaxStack.size() - 1][\"min\"]; }\n\n  // O(1) time | O(1) space\n  int getMax() { return minMaxStack[minMaxStack.size() - 1][\"max\"]; }\n};"
      ]
    },
    "csharp": {
      "Language": "csharp",
      "StartingCode": "public class Program {\n\t// Feel free to add new properties and methods to the class.\n\tpublic class MinMaxStack {\n\t\tpublic int Peek() {\n\t\t\t// Write your code here.\n\t\t\treturn -1;\n\t\t}\n\n\t\tpublic int Pop() {\n\t\t\t// Write your code here.\n\t\t\treturn -1;\n\t\t}\n\n\n\t\tpublic void Push(int number) {\n\t\t\t// Write your code here.\n\t\t}\n\n\n\t\tpublic int GetMin() {\n\t\t\t// Write your code here.\n\t\t\treturn -1;\n\t\t}\n\n\n\t\tpublic int GetMax() {\n\t\t\t// Write your code here.\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n",
      "StartingTest": "public class ProgramTest {\n\n\tpublic void testMinMaxPeek(\n\t\tint min,\n\t\tint max,\n\t\tint Peek,\n\t\tProgram.MinMaxStack stack\n\t\t) {\n\t\tUtils.AssertTrue(stack.GetMin() == min);\n\t\tUtils.AssertTrue(stack.GetMax() == max);\n\t\tUtils.AssertTrue(stack.Peek() == Peek);\n\t}\n\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.MinMaxStack stack = new Program.MinMaxStack();\n\t\tstack.Push(2);\n\t\ttestMinMaxPeek(2, 2, 2, stack);\n\t\tstack.Push(7);\n\t\ttestMinMaxPeek(2, 7, 7, stack);\n\t\tstack.Push(1);\n\t\ttestMinMaxPeek(1, 7, 1, stack);\n\t\tstack.Push(8);\n\t\ttestMinMaxPeek(1, 8, 8, stack);\n\t\tstack.Push(3);\n\t\ttestMinMaxPeek(1, 8, 3, stack);\n\t\tstack.Push(9);\n\t\ttestMinMaxPeek(1, 9, 9, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 9);\n\t\ttestMinMaxPeek(1, 8, 3, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 3);\n\t\ttestMinMaxPeek(1, 8, 8, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 8);\n\t\ttestMinMaxPeek(1, 7, 1, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 1);\n\t\ttestMinMaxPeek(2, 7, 7, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 7);\n\t\ttestMinMaxPeek(2, 2, 2, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 2);\n\t}\n\n\t[Test]\n\tpublic void TestCase2() {\n\t\tProgram.MinMaxStack stack = new Program.MinMaxStack();\n\t\tstack.Push(5);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t\tstack.Push(5);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t\tstack.Push(5);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t\tstack.Push(5);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t\tstack.Push(8);\n\t\ttestMinMaxPeek(5, 8, 8, stack);\n\t\tstack.Push(8);\n\t\ttestMinMaxPeek(5, 8, 8, stack);\n\t\tstack.Push(0);\n\t\ttestMinMaxPeek(0, 8, 0, stack);\n\t\tstack.Push(8);\n\t\ttestMinMaxPeek(0, 8, 8, stack);\n\t\tstack.Push(9);\n\t\ttestMinMaxPeek(0, 9, 9, stack);\n\t\tstack.Push(5);\n\t\ttestMinMaxPeek(0, 9, 5, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 5);\n\t\ttestMinMaxPeek(0, 9, 9, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 9);\n\t\ttestMinMaxPeek(0, 8, 8, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 8);\n\t\ttestMinMaxPeek(0, 8, 0, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 0);\n\t\ttestMinMaxPeek(5, 8, 8, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 8);\n\t\ttestMinMaxPeek(5, 8, 8, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 8);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 5);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 5);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 5);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 5);\n\t}\n\n\t[Test]\n\tpublic void TestCase3() {\n\t\tProgram.MinMaxStack stack = new Program.MinMaxStack();\n\t\tstack.Push(2);\n\t\ttestMinMaxPeek(2, 2, 2, stack);\n\t\tstack.Push(0);\n\t\ttestMinMaxPeek(0, 2, 0, stack);\n\t\tstack.Push(5);\n\t\ttestMinMaxPeek(0, 5, 5, stack);\n\t\tstack.Push(4);\n\t\ttestMinMaxPeek(0, 5, 4, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 4);\n\t\ttestMinMaxPeek(0, 5, 5, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 5);\n\t\ttestMinMaxPeek(0, 2, 0, stack);\n\t\tstack.Push(4);\n\t\ttestMinMaxPeek(0, 4, 4, stack);\n\t\tstack.Push(11);\n\t\ttestMinMaxPeek(0, 11, 11, stack);\n\t\tstack.Push(-11);\n\t\ttestMinMaxPeek(-11, 11, -11, stack);\n\t\tUtils.AssertTrue(stack.Pop() == -11);\n\t\ttestMinMaxPeek(0, 11, 11, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 11);\n\t\ttestMinMaxPeek(0, 4, 4, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 4);\n\t\ttestMinMaxPeek(0, 2, 0, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 0);\n\t\ttestMinMaxPeek(2, 2, 2, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 2);\n\t\tstack.Push(6);\n\t\ttestMinMaxPeek(6, 6, 6, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 6);\n\t}\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npublic class ProgramTest {\n\tpublic void testMinMaxPeek(\n\t\tint min,\n\t\tint max,\n\t\tint Peek,\n\t\tProgram.MinMaxStack stack\n\t\t) {\n\t\tUtils.AssertTrue(stack.GetMin() == min);\n\t\tUtils.AssertTrue(stack.GetMax() == max);\n\t\tUtils.AssertTrue(stack.Peek() == Peek);\n\t}\n\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.MinMaxStack stack = new Program.MinMaxStack();\n\t\tstack.Push(5);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t\tstack.Push(7);\n\t\ttestMinMaxPeek(5, 7, 7, stack);\n\t\tstack.Push(2);\n\t\ttestMinMaxPeek(2, 7, 2, stack);\n\t\tUtils.AssertTrue(stack.Pop() == 2);\n\t\tUtils.AssertTrue(stack.Pop() == 7);\n\t\ttestMinMaxPeek(5, 5, 5, stack);\n\t}\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nusing System;\nusing System.Collections.Generic;\n\npublic class Program {\n\tpublic class MinMaxStack {\n\t\tList<Dictionary<string, int> > minMaxStack = new List<Dictionary<string, int> >();\n\t\tList<int> stack = new List<int>();\n\n\t\t// O(1) time | O(1) space\n\t\tpublic int Peek() {\n\t\t\treturn stack[stack.Count - 1];\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic int Pop() {\n\t\t\tminMaxStack.RemoveAt(minMaxStack.Count - 1);\n\t\t\tvar val = stack[stack.Count - 1];\n\t\t\tstack.RemoveAt(stack.Count - 1);\n\t\t\treturn val;\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void Push(int number) {\n\t\t\tDictionary<string, int> newMinMax = new Dictionary<string, int>();\n\t\t\tnewMinMax.Add(\"min\", number);\n\t\t\tnewMinMax.Add(\"max\", number);\n\t\t\tif (minMaxStack.Count > 0) {\n\t\t\t\tDictionary<string, int> lastMinMax = new Dictionary<string, int>(\n\t\t\t\t\tminMaxStack[minMaxStack.Count - 1]\n\t\t\t\t\t);\n\t\t\t\tnewMinMax[\"min\"] = Math.Min(lastMinMax[\"min\"], number);\n\t\t\t\tnewMinMax[\"max\"] = Math.Max(lastMinMax[\"max\"], number);\n\t\t\t}\n\t\t\tminMaxStack.Add(newMinMax);\n\t\t\tstack.Add(number);\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic int GetMin() {\n\t\t\treturn minMaxStack[minMaxStack.Count - 1][\"min\"];\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic int GetMax() {\n\t\t\treturn minMaxStack[minMaxStack.Count - 1][\"max\"];\n\t\t}\n\t}\n}\n"
      ]
    },
    "go": {
      "Language": "go",
      "StartingCode": "package main\n\ntype MinMaxStack struct {\n\t// Write your code here.\n}\n\nfunc NewMinMaxStack() *MinMaxStack {\n\t// Write your code here.\n\treturn nil\n}\n\nfunc (stack *MinMaxStack) Peek() int {\n\t// Write your code here.\n\treturn -1\n}\n\nfunc (stack *MinMaxStack) Pop() int {\n\t// Write your code here.\n\treturn -1\n}\n\nfunc (stack *MinMaxStack) Push(number int) {\n\t// Write your code here.\n}\n\nfunc (stack *MinMaxStack) GetMin() int {\n\t// Write your code here.\n\treturn -1\n}\n\nfunc (stack *MinMaxStack) GetMax() int {\n\t// Write your code here.\n\treturn -1\n}\n",
      "StartingTest": "package main\n\nfunc testMinMaxPeek(t *TestCase, min, max, peek int, stack *MinMaxStack) {\n\tif min != stack.GetMin() {\n\t\tt.Fail()\n\t}\n\tif max != stack.GetMax() {\n\t\tt.Fail()\n\t}\n\tif peek != stack.Peek() {\n\t\tt.Fail()\n\t}\n}\n\nfunc assertEqual(t *TestCase, a, b int) {\n\tif a != b {\n\t\tt.Fail()\n\t}\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tstack := NewMinMaxStack()\n\tstack.Push(2)\n\ttestMinMaxPeek(t, 2, 2, 2, stack)\n\tstack.Push(7)\n\ttestMinMaxPeek(t, 2, 7, 7, stack)\n\tstack.Push(1)\n\ttestMinMaxPeek(t, 1, 7, 1, stack)\n\tstack.Push(8)\n\ttestMinMaxPeek(t, 1, 8, 8, stack)\n\tstack.Push(3)\n\ttestMinMaxPeek(t, 1, 8, 3, stack)\n\tstack.Push(9)\n\ttestMinMaxPeek(t, 1, 9, 9, stack)\n\tassertEqual(t, stack.Pop(), 9)\n\ttestMinMaxPeek(t, 1, 8, 3, stack)\n\tassertEqual(t, stack.Pop(), 3)\n\ttestMinMaxPeek(t, 1, 8, 8, stack)\n\tassertEqual(t, stack.Pop(), 8)\n\ttestMinMaxPeek(t, 1, 7, 1, stack)\n\tassertEqual(t, stack.Pop(), 1)\n\ttestMinMaxPeek(t, 2, 7, 7, stack)\n\tassertEqual(t, stack.Pop(), 7)\n\ttestMinMaxPeek(t, 2, 2, 2, stack)\n\tassertEqual(t, stack.Pop(), 2)\n}\n\nfunc (s *TestSuite) TestCase2(t *TestCase) {\n\tstack := NewMinMaxStack()\n\tstack.Push(5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tstack.Push(5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tstack.Push(5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tstack.Push(5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tstack.Push(8)\n\ttestMinMaxPeek(t, 5, 8, 8, stack)\n\tstack.Push(8)\n\ttestMinMaxPeek(t, 5, 8, 8, stack)\n\tstack.Push(0)\n\ttestMinMaxPeek(t, 0, 8, 0, stack)\n\tstack.Push(8)\n\ttestMinMaxPeek(t, 0, 8, 8, stack)\n\tstack.Push(9)\n\ttestMinMaxPeek(t, 0, 9, 9, stack)\n\tstack.Push(5)\n\ttestMinMaxPeek(t, 0, 9, 5, stack)\n\tassertEqual(t, stack.Pop(), 5)\n\ttestMinMaxPeek(t, 0, 9, 9, stack)\n\tassertEqual(t, stack.Pop(), 9)\n\ttestMinMaxPeek(t, 0, 8, 8, stack)\n\tassertEqual(t, stack.Pop(), 8)\n\ttestMinMaxPeek(t, 0, 8, 0, stack)\n\tassertEqual(t, stack.Pop(), 0)\n\ttestMinMaxPeek(t, 5, 8, 8, stack)\n\tassertEqual(t, stack.Pop(), 8)\n\ttestMinMaxPeek(t, 5, 8, 8, stack)\n\tassertEqual(t, stack.Pop(), 8)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tassertEqual(t, stack.Pop(), 5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tassertEqual(t, stack.Pop(), 5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tassertEqual(t, stack.Pop(), 5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tassertEqual(t, stack.Pop(), 5)\n}\n\nfunc (s *TestSuite) TestCase3(t *TestCase) {\n\tstack := NewMinMaxStack()\n\tstack.Push(2)\n\ttestMinMaxPeek(t, 2, 2, 2, stack)\n\tstack.Push(0)\n\ttestMinMaxPeek(t, 0, 2, 0, stack)\n\tstack.Push(5)\n\ttestMinMaxPeek(t, 0, 5, 5, stack)\n\tstack.Push(4)\n\ttestMinMaxPeek(t, 0, 5, 4, stack)\n\tassertEqual(t, stack.Pop(), 4)\n\ttestMinMaxPeek(t, 0, 5, 5, stack)\n\tassertEqual(t, stack.Pop(), 5)\n\ttestMinMaxPeek(t, 0, 2, 0, stack)\n\tstack.Push(4)\n\ttestMinMaxPeek(t, 0, 4, 4, stack)\n\tstack.Push(11)\n\ttestMinMaxPeek(t, 0, 11, 11, stack)\n\tstack.Push(-11)\n\ttestMinMaxPeek(t, -11, 11, -11, stack)\n\tassertEqual(t, stack.Pop(), -11)\n\ttestMinMaxPeek(t, 0, 11, 11, stack)\n\tassertEqual(t, stack.Pop(), 11)\n\ttestMinMaxPeek(t, 0, 4, 4, stack)\n\tassertEqual(t, stack.Pop(), 4)\n\ttestMinMaxPeek(t, 0, 2, 0, stack)\n\tassertEqual(t, stack.Pop(), 0)\n\ttestMinMaxPeek(t, 2, 2, 2, stack)\n\tassertEqual(t, stack.Pop(), 2)\n\tstack.Push(6)\n\ttestMinMaxPeek(t, 6, 6, 6, stack)\n\tassertEqual(t, stack.Pop(), 6)\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nfunc testMinMaxPeek(t *TestCase, min, max, peek int, stack *MinMaxStack) {\n\tif min != stack.GetMin() {\n\t\tt.Fail()\n\t}\n\tif max != stack.GetMax() {\n\t\tt.Fail()\n\t}\n\tif peek != stack.Peek() {\n\t\tt.Fail()\n\t}\n}\n\nfunc assertEqual(t *TestCase, a, b int) {\n\tif a != b {\n\t\tt.Fail()\n\t}\n}\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tstack := NewMinMaxStack()\n\tstack.Push(5)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n\tstack.Push(7)\n\ttestMinMaxPeek(t, 5, 7, 7, stack)\n\tstack.Push(2)\n\ttestMinMaxPeek(t, 2, 7, 2, stack)\n\tassertEqual(t, stack.Pop(), 2)\n\tassertEqual(t, stack.Pop(), 7)\n\ttestMinMaxPeek(t, 5, 5, 5, stack)\n}",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\npackage main\n\ntype MinMaxStack struct {\n\tstack       []int\n\tminMaxStack []entry\n}\n\ntype entry struct {\n\tmin int\n\tmax int\n}\n\nfunc NewMinMaxStack() *MinMaxStack {\n\treturn &MinMaxStack{}\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) Peek() int {\n\treturn stack.stack[len(stack.stack)-1]\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) Pop() int {\n\tstack.minMaxStack = stack.minMaxStack[:len(stack.minMaxStack)-1]\n\tout := stack.stack[len(stack.stack)-1]\n\tstack.stack = stack.stack[:len(stack.stack)-1]\n\treturn out\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) Push(number int) {\n\tnewMinMax := entry{min: number, max: number}\n\tif len(stack.minMaxStack) > 0 {\n\t\tlastMinMax := stack.minMaxStack[len(stack.minMaxStack)-1]\n\t\tnewMinMax.min = min(lastMinMax.min, number)\n\t\tnewMinMax.max = max(lastMinMax.max, number)\n\t}\n\tstack.minMaxStack = append(stack.minMaxStack, newMinMax)\n\tstack.stack = append(stack.stack, number)\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) GetMin() int {\n\treturn stack.minMaxStack[len(stack.minMaxStack)-1].min\n}\n\n// O(1) time | O(1) space\nfunc (stack *MinMaxStack) GetMax() int {\n\treturn stack.minMaxStack[len(stack.minMaxStack)-1].max\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n"
      ]
    },
    "java": {
      "Language": "java",
      "StartingCode": "import java.util.*;\n\nclass Program {\n  // Feel free to add new properties and methods to the class.\n  static class MinMaxStack {\n    public int peek() {\n      // Write your code here.\n      return -1;\n    }\n\n    public int pop() {\n      // Write your code here.\n      return -1;\n    }\n\n    public void push(Integer number) {\n      // Write your code here.\n    }\n\n    public int getMin() {\n      // Write your code here.\n      return -1;\n    }\n\n    public int getMax() {\n      // Write your code here.\n      return -1;\n    }\n  }\n}\n",
      "StartingTest": "class ProgramTest {\n\n  public void testMinMaxPeek(int min, int max, int peek, Program.MinMaxStack stack) {\n    Utils.assertTrue(stack.getMin() == min);\n    Utils.assertTrue(stack.getMax() == max);\n    Utils.assertTrue(stack.peek() == peek);\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.MinMaxStack stack = new Program.MinMaxStack();\n    stack.push(2);\n    testMinMaxPeek(2, 2, 2, stack);\n    stack.push(7);\n    testMinMaxPeek(2, 7, 7, stack);\n    stack.push(1);\n    testMinMaxPeek(1, 7, 1, stack);\n    stack.push(8);\n    testMinMaxPeek(1, 8, 8, stack);\n    stack.push(3);\n    testMinMaxPeek(1, 8, 3, stack);\n    stack.push(9);\n    testMinMaxPeek(1, 9, 9, stack);\n    Utils.assertTrue(stack.pop() == 9);\n    testMinMaxPeek(1, 8, 3, stack);\n    Utils.assertTrue(stack.pop() == 3);\n    testMinMaxPeek(1, 8, 8, stack);\n    Utils.assertTrue(stack.pop() == 8);\n    testMinMaxPeek(1, 7, 1, stack);\n    Utils.assertTrue(stack.pop() == 1);\n    testMinMaxPeek(2, 7, 7, stack);\n    Utils.assertTrue(stack.pop() == 7);\n    testMinMaxPeek(2, 2, 2, stack);\n    Utils.assertTrue(stack.pop() == 2);\n  }\n\n  @Test\n  public void TestCase2() {\n    Program.MinMaxStack stack = new Program.MinMaxStack();\n    stack.push(5);\n    testMinMaxPeek(5, 5, 5, stack);\n    stack.push(5);\n    testMinMaxPeek(5, 5, 5, stack);\n    stack.push(5);\n    testMinMaxPeek(5, 5, 5, stack);\n    stack.push(5);\n    testMinMaxPeek(5, 5, 5, stack);\n    stack.push(8);\n    testMinMaxPeek(5, 8, 8, stack);\n    stack.push(8);\n    testMinMaxPeek(5, 8, 8, stack);\n    stack.push(0);\n    testMinMaxPeek(0, 8, 0, stack);\n    stack.push(8);\n    testMinMaxPeek(0, 8, 8, stack);\n    stack.push(9);\n    testMinMaxPeek(0, 9, 9, stack);\n    stack.push(5);\n    testMinMaxPeek(0, 9, 5, stack);\n    Utils.assertTrue(stack.pop() == 5);\n    testMinMaxPeek(0, 9, 9, stack);\n    Utils.assertTrue(stack.pop() == 9);\n    testMinMaxPeek(0, 8, 8, stack);\n    Utils.assertTrue(stack.pop() == 8);\n    testMinMaxPeek(0, 8, 0, stack);\n    Utils.assertTrue(stack.pop() == 0);\n    testMinMaxPeek(5, 8, 8, stack);\n    Utils.assertTrue(stack.pop() == 8);\n    testMinMaxPeek(5, 8, 8, stack);\n    Utils.assertTrue(stack.pop() == 8);\n    testMinMaxPeek(5, 5, 5, stack);\n    Utils.assertTrue(stack.pop() == 5);\n    testMinMaxPeek(5, 5, 5, stack);\n    Utils.assertTrue(stack.pop() == 5);\n    testMinMaxPeek(5, 5, 5, stack);\n    Utils.assertTrue(stack.pop() == 5);\n    testMinMaxPeek(5, 5, 5, stack);\n    Utils.assertTrue(stack.pop() == 5);\n  }\n\n  @Test\n  public void TestCase3() {\n    Program.MinMaxStack stack = new Program.MinMaxStack();\n    stack.push(2);\n    testMinMaxPeek(2, 2, 2, stack);\n    stack.push(0);\n    testMinMaxPeek(0, 2, 0, stack);\n    stack.push(5);\n    testMinMaxPeek(0, 5, 5, stack);\n    stack.push(4);\n    testMinMaxPeek(0, 5, 4, stack);\n    Utils.assertTrue(stack.pop() == 4);\n    testMinMaxPeek(0, 5, 5, stack);\n    Utils.assertTrue(stack.pop() == 5);\n    testMinMaxPeek(0, 2, 0, stack);\n    stack.push(4);\n    testMinMaxPeek(0, 4, 4, stack);\n    stack.push(11);\n    testMinMaxPeek(0, 11, 11, stack);\n    stack.push(-11);\n    testMinMaxPeek(-11, 11, -11, stack);\n    Utils.assertTrue(stack.pop() == -11);\n    testMinMaxPeek(0, 11, 11, stack);\n    Utils.assertTrue(stack.pop() == 11);\n    testMinMaxPeek(0, 4, 4, stack);\n    Utils.assertTrue(stack.pop() == 4);\n    testMinMaxPeek(0, 2, 0, stack);\n    Utils.assertTrue(stack.pop() == 0);\n    testMinMaxPeek(2, 2, 2, stack);\n    Utils.assertTrue(stack.pop() == 2);\n    stack.push(6);\n    testMinMaxPeek(6, 6, 6, stack);\n    Utils.assertTrue(stack.pop() == 6);\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest {\n  public void testMinMaxPeek(int min, int max, int peek, Program.MinMaxStack stack) {\n    Utils.assertTrue(stack.getMin() == min);\n    Utils.assertTrue(stack.getMax() == max);\n    Utils.assertTrue(stack.peek() == peek);\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.MinMaxStack stack = new Program.MinMaxStack();\n    stack.push(5);\n    testMinMaxPeek(5, 5, 5, stack);\n    stack.push(7);\n    testMinMaxPeek(5, 7, 7, stack);\n    stack.push(2);\n    testMinMaxPeek(2, 7, 2, stack);\n    Utils.assertTrue(stack.pop() == 2);\n    Utils.assertTrue(stack.pop() == 7);\n    testMinMaxPeek(5, 5, 5, stack);\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  static class MinMaxStack {\n    List<Map<String, Integer>> minMaxStack = new ArrayList<Map<String, Integer>>();\n    List<Integer> stack = new ArrayList<Integer>();\n\n    // O(1) time | O(1) space\n    public int peek() {\n      return stack.get(stack.size() - 1);\n    }\n\n    // O(1) time | O(1) space\n    public int pop() {\n      minMaxStack.remove(minMaxStack.size() - 1);\n      return stack.remove(stack.size() - 1);\n    }\n\n    // O(1) time | O(1) space\n    public void push(int number) {\n      Map<String, Integer> newMinMax = new HashMap<String, Integer>();\n      newMinMax.put(\"min\", number);\n      newMinMax.put(\"max\", number);\n      if (minMaxStack.size() > 0) {\n        Map<String, Integer> lastMinMax =\n            new HashMap<String, Integer>(minMaxStack.get(minMaxStack.size() - 1));\n        newMinMax.replace(\"min\", Math.min(lastMinMax.get(\"min\"), number));\n        newMinMax.replace(\"max\", Math.max(lastMinMax.get(\"max\"), number));\n      }\n      minMaxStack.add(newMinMax);\n      stack.add(number);\n    }\n\n    // O(1) time | O(1) space\n    public int getMin() {\n      return minMaxStack.get(minMaxStack.size() - 1).get(\"min\");\n    }\n\n    // O(1) time | O(1) space\n    public int getMax() {\n      return minMaxStack.get(minMaxStack.size() - 1).get(\"max\");\n    }\n  }\n}\n"
      ]
    },
    "javascript": {
      "Language": "javascript",
      "StartingCode": "// Feel free to add new properties and methods to the class.\nclass MinMaxStack {\n  peek() {\n    // Write your code here.\n  }\n\n  pop() {\n    // Write your code here.\n  }\n\n  push(number) {\n    // Write your code here.\n  }\n\n  getMin() {\n    // Write your code here.\n  }\n\n  getMax() {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.MinMaxStack = MinMaxStack;\n",
      "StartingTest": "const program = require('./program');\nconst chai = require('chai');\n\nfunction testMinMaxPeek(min, max, peek, stack) {\n  chai.expect(stack.getMin()).to.deep.equal(min);\n  chai.expect(stack.getMax()).to.deep.equal(max);\n  chai.expect(stack.peek()).to.deep.equal(peek);\n}\n\nit('Test Case #1', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(2);\n  testMinMaxPeek(2, 2, 2, stack);\n  stack.push(7);\n  testMinMaxPeek(2, 7, 7, stack);\n  stack.push(1);\n  testMinMaxPeek(1, 7, 1, stack);\n  stack.push(8);\n  testMinMaxPeek(1, 8, 8, stack);\n  stack.push(3);\n  testMinMaxPeek(1, 8, 3, stack);\n  stack.push(9);\n  testMinMaxPeek(1, 9, 9, stack);\n  chai.expect(stack.pop()).to.deep.equal(9);\n  testMinMaxPeek(1, 8, 3, stack);\n  chai.expect(stack.pop()).to.deep.equal(3);\n  testMinMaxPeek(1, 8, 8, stack);\n  chai.expect(stack.pop()).to.deep.equal(8);\n  testMinMaxPeek(1, 7, 1, stack);\n  chai.expect(stack.pop()).to.deep.equal(1);\n  testMinMaxPeek(2, 7, 7, stack);\n  chai.expect(stack.pop()).to.deep.equal(7);\n  testMinMaxPeek(2, 2, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n});\n\nit('Test Case #2', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(8);\n  testMinMaxPeek(5, 8, 8, stack);\n  stack.push(8);\n  testMinMaxPeek(5, 8, 8, stack);\n  stack.push(0);\n  testMinMaxPeek(0, 8, 0, stack);\n  stack.push(8);\n  testMinMaxPeek(0, 8, 8, stack);\n  stack.push(9);\n  testMinMaxPeek(0, 9, 9, stack);\n  stack.push(5);\n  testMinMaxPeek(0, 9, 5, stack);\n  chai.expect(stack.pop()).to.deep.equal(5);\n  testMinMaxPeek(0, 9, 9, stack);\n  chai.expect(stack.pop()).to.deep.equal(9);\n  testMinMaxPeek(0, 8, 8, stack);\n  chai.expect(stack.pop()).to.deep.equal(8);\n  testMinMaxPeek(0, 8, 0, stack);\n  chai.expect(stack.pop()).to.deep.equal(0);\n  testMinMaxPeek(5, 8, 8, stack);\n  chai.expect(stack.pop()).to.deep.equal(8);\n  testMinMaxPeek(5, 8, 8, stack);\n  chai.expect(stack.pop()).to.deep.equal(8);\n  testMinMaxPeek(5, 5, 5, stack);\n  chai.expect(stack.pop()).to.deep.equal(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  chai.expect(stack.pop()).to.deep.equal(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  chai.expect(stack.pop()).to.deep.equal(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  chai.expect(stack.pop()).to.deep.equal(5);\n});\n\nit('Test Case #3', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(2);\n  testMinMaxPeek(2, 2, 2, stack);\n  stack.push(0);\n  testMinMaxPeek(0, 2, 0, stack);\n  stack.push(5);\n  testMinMaxPeek(0, 5, 5, stack);\n  stack.push(4);\n  testMinMaxPeek(0, 5, 4, stack);\n  chai.expect(stack.pop()).to.deep.equal(4);\n  testMinMaxPeek(0, 5, 5, stack);\n  chai.expect(stack.pop()).to.deep.equal(5);\n  testMinMaxPeek(0, 2, 0, stack);\n  stack.push(4);\n  testMinMaxPeek(0, 4, 4, stack);\n  stack.push(11);\n  testMinMaxPeek(0, 11, 11, stack);\n  stack.push(-11);\n  testMinMaxPeek(-11, 11, -11, stack);\n  chai.expect(stack.pop()).to.deep.equal(-11);\n  testMinMaxPeek(0, 11, 11, stack);\n  chai.expect(stack.pop()).to.deep.equal(11);\n  testMinMaxPeek(0, 4, 4, stack);\n  chai.expect(stack.pop()).to.deep.equal(4);\n  testMinMaxPeek(0, 2, 0, stack);\n  chai.expect(stack.pop()).to.deep.equal(0);\n  testMinMaxPeek(2, 2, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n  stack.push(6);\n  testMinMaxPeek(6, 6, 6, stack);\n  chai.expect(stack.pop()).to.deep.equal(6);\n});\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nfunction testMinMaxPeek(min, max, peek, stack) {\n  chai.expect(stack.getMin()).to.deep.equal(min);\n  chai.expect(stack.getMax()).to.deep.equal(max);\n  chai.expect(stack.peek()).to.deep.equal(peek);\n}\n\nit('Test Case #1', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(7);\n  testMinMaxPeek(5, 7, 7, stack);\n  stack.push(2);\n  testMinMaxPeek(2, 7, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n  chai.expect(stack.pop()).to.deep.equal(7);\n  testMinMaxPeek(5, 5, 5, stack);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass MinMaxStack {\n  constructor() {\n    this.minMaxStack = [];\n    this.stack = [];\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  // O(1) time | O(1) space\n  pop() {\n    this.minMaxStack.pop();\n    return this.stack.pop();\n  }\n\n  // O(1) time | O(1) space\n  push(number) {\n    const newMinMax = {min: number, max: number};\n    if (this.minMaxStack.length) {\n      const lastMinMax = this.minMaxStack[this.minMaxStack.length - 1];\n      newMinMax.min = Math.min(lastMinMax.min, number);\n      newMinMax.max = Math.max(lastMinMax.max, number);\n    }\n    this.minMaxStack.push(newMinMax);\n    this.stack.push(number);\n  }\n\n  // O(1) time | O(1) space\n  getMin() {\n    return this.minMaxStack[this.minMaxStack.length - 1].min;\n  }\n\n  // O(1) time | O(1) space\n  getMax() {\n    return this.minMaxStack[this.minMaxStack.length - 1].max;\n  }\n}\n\n// Do not edit the line below.\nexports.MinMaxStack = MinMaxStack;\n"
      ]
    },
    "python": {
      "Language": "python",
      "StartingCode": "# Feel free to add new properties and methods to the class.\nclass MinMaxStack:\n    def peek(self):\n        # Write your code here.\n        pass\n\n    def pop(self):\n        # Write your code here.\n        pass\n\n    def push(self, number):\n        # Write your code here.\n        pass\n\n    def getMin(self):\n        # Write your code here.\n        pass\n\n    def getMax(self):\n        # Write your code here.\n        pass\n",
      "StartingTest": "import program\nimport unittest\n\n\ndef testMinMaxPeek(self, min, max, peek, stack):\n    self.assertEqual(stack.getMin(), min)\n    self.assertEqual(stack.getMax(), max)\n    self.assertEqual(stack.peek(), peek)\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        stack = program.MinMaxStack()\n        stack.push(2)\n        testMinMaxPeek(self, 2, 2, 2, stack)\n        stack.push(7)\n        testMinMaxPeek(self, 2, 7, 7, stack)\n        stack.push(1)\n        testMinMaxPeek(self, 1, 7, 1, stack)\n        stack.push(8)\n        testMinMaxPeek(self, 1, 8, 8, stack)\n        stack.push(3)\n        testMinMaxPeek(self, 1, 8, 3, stack)\n        stack.push(9)\n        testMinMaxPeek(self, 1, 9, 9, stack)\n        self.assertEqual(stack.pop(), 9)\n        testMinMaxPeek(self, 1, 8, 3, stack)\n        self.assertEqual(stack.pop(), 3)\n        testMinMaxPeek(self, 1, 8, 8, stack)\n        self.assertEqual(stack.pop(), 8)\n        testMinMaxPeek(self, 1, 7, 1, stack)\n        self.assertEqual(stack.pop(), 1)\n        testMinMaxPeek(self, 2, 7, 7, stack)\n        self.assertEqual(stack.pop(), 7)\n        testMinMaxPeek(self, 2, 2, 2, stack)\n        self.assertEqual(stack.pop(), 2)\n\n    def test_case_2(self):\n        stack = program.MinMaxStack()\n        stack.push(5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        stack.push(5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        stack.push(5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        stack.push(5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        stack.push(8)\n        testMinMaxPeek(self, 5, 8, 8, stack)\n        stack.push(8)\n        testMinMaxPeek(self, 5, 8, 8, stack)\n        stack.push(0)\n        testMinMaxPeek(self, 0, 8, 0, stack)\n        stack.push(8)\n        testMinMaxPeek(self, 0, 8, 8, stack)\n        stack.push(9)\n        testMinMaxPeek(self, 0, 9, 9, stack)\n        stack.push(5)\n        testMinMaxPeek(self, 0, 9, 5, stack)\n        self.assertEqual(stack.pop(), 5)\n        testMinMaxPeek(self, 0, 9, 9, stack)\n        self.assertEqual(stack.pop(), 9)\n        testMinMaxPeek(self, 0, 8, 8, stack)\n        self.assertEqual(stack.pop(), 8)\n        testMinMaxPeek(self, 0, 8, 0, stack)\n        self.assertEqual(stack.pop(), 0)\n        testMinMaxPeek(self, 5, 8, 8, stack)\n        self.assertEqual(stack.pop(), 8)\n        testMinMaxPeek(self, 5, 8, 8, stack)\n        self.assertEqual(stack.pop(), 8)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        self.assertEqual(stack.pop(), 5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        self.assertEqual(stack.pop(), 5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        self.assertEqual(stack.pop(), 5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        self.assertEqual(stack.pop(), 5)\n\n    def test_case_3(self):\n        stack = program.MinMaxStack()\n        stack.push(2)\n        testMinMaxPeek(self, 2, 2, 2, stack)\n        stack.push(0)\n        testMinMaxPeek(self, 0, 2, 0, stack)\n        stack.push(5)\n        testMinMaxPeek(self, 0, 5, 5, stack)\n        stack.push(4)\n        testMinMaxPeek(self, 0, 5, 4, stack)\n        self.assertEqual(stack.pop(), 4)\n        testMinMaxPeek(self, 0, 5, 5, stack)\n        self.assertEqual(stack.pop(), 5)\n        testMinMaxPeek(self, 0, 2, 0, stack)\n        stack.push(4)\n        testMinMaxPeek(self, 0, 4, 4, stack)\n        stack.push(11)\n        testMinMaxPeek(self, 0, 11, 11, stack)\n        stack.push(-11)\n        testMinMaxPeek(self, -11, 11, -11, stack)\n        self.assertEqual(stack.pop(), -11)\n        testMinMaxPeek(self, 0, 11, 11, stack)\n        self.assertEqual(stack.pop(), 11)\n        testMinMaxPeek(self, 0, 4, 4, stack)\n        self.assertEqual(stack.pop(), 4)\n        testMinMaxPeek(self, 0, 2, 0, stack)\n        self.assertEqual(stack.pop(), 0)\n        testMinMaxPeek(self, 2, 2, 2, stack)\n        self.assertEqual(stack.pop(), 2)\n        stack.push(6)\n        testMinMaxPeek(self, 6, 6, 6, stack)\n        self.assertEqual(stack.pop(), 6)\n",
      "SandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\ndef testMinMaxPeek(self, min, max, peek, stack):\n    self.assertEqual(stack.getMin(), min)\n    self.assertEqual(stack.getMax(), max)\n    self.assertEqual(stack.peek(), peek)\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        stack = program.MinMaxStack()\n        stack.push(5)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n        stack.push(7)\n        testMinMaxPeek(self, 5, 7, 7, stack)\n        stack.push(2)\n        testMinMaxPeek(self, 2, 7, 2, stack)\n        self.assertEqual(stack.pop(), 2)\n        self.assertEqual(stack.pop(), 7)\n        testMinMaxPeek(self, 5, 5, 5, stack)\n",
      "Solutions": [
        "# Copyright © 2020 Code Complete. All rights reserved.\n\nclass MinMaxStack:\n    def __init__(self):\n        self.minMaxStack = []\n        self.stack = []\n\n    # O(1) time | O(1) space\n    def peek(self):\n        return self.stack[len(self.stack) - 1]\n\n    # O(1) time | O(1) space\n    def pop(self):\n        self.minMaxStack.pop()\n        return self.stack.pop()\n\n    # O(1) time | O(1) space\n    def push(self, number):\n        newMinMax = {\"min\": number, \"max\": number}\n        if len(self.minMaxStack):\n            lastMinMax = self.minMaxStack[len(self.minMaxStack) - 1]\n            newMinMax[\"min\"] = min(lastMinMax[\"min\"], number)\n            newMinMax[\"max\"] = max(lastMinMax[\"max\"], number)\n        self.minMaxStack.append(newMinMax)\n        self.stack.append(number)\n\n    # O(1) time | O(1) space\n    def getMin(self):\n        return self.minMaxStack[len(self.minMaxStack) - 1][\"min\"]\n\n    # O(1) time | O(1) space\n    def getMax(self):\n        return self.minMaxStack[len(self.minMaxStack) - 1][\"max\"]\n"
      ]
    },
    "swift": {
      "Language": "swift",
      "StartingCode": "class Program {\n  // Feel free to add new properties and methods to the class.\n  class MinMaxStack {\n    func peek() -> Int? {\n      // Write your code here.\n      return nil\n    }\n\n    func pop() -> Int? {\n      // Write your code here.\n      return nil\n    }\n\n    func push(number: Int) {\n      // Write your code here.\n    }\n\n    func getMin() -> Int? {\n      // Write your code here.\n      return nil\n    }\n\n    func getMax() -> Int? {\n      // Write your code here.\n      return nil\n    }\n  }\n}\n",
      "StartingTest": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let firstTest = Program.MinMaxStack()\n      firstTest.push(number: 2)\n      try testMinMaxPeek(stack: firstTest, min: 2, max: 2, peek: 2)\n      firstTest.push(number: 7)\n      try testMinMaxPeek(stack: firstTest, min: 2, max: 7, peek: 7)\n      firstTest.push(number: 1)\n      try testMinMaxPeek(stack: firstTest, min: 1, max: 7, peek: 1)\n      firstTest.push(number: 8)\n      try testMinMaxPeek(stack: firstTest, min: 1, max: 8, peek: 8)\n      firstTest.push(number: 3)\n      try testMinMaxPeek(stack: firstTest, min: 1, max: 8, peek: 3)\n      firstTest.push(number: 9)\n      try testMinMaxPeek(stack: firstTest, min: 1, max: 9, peek: 9)\n      try assertEqual(9, firstTest.pop())\n      try testMinMaxPeek(stack: firstTest, min: 1, max: 8, peek: 3)\n      try assertEqual(3, firstTest.pop())\n      try testMinMaxPeek(stack: firstTest, min: 1, max: 8, peek: 8)\n      try assertEqual(8, firstTest.pop())\n      try testMinMaxPeek(stack: firstTest, min: 1, max: 7, peek: 1)\n      try assertEqual(1, firstTest.pop())\n      try testMinMaxPeek(stack: firstTest, min: 2, max: 7, peek: 7)\n      try assertEqual(7, firstTest.pop())\n      try testMinMaxPeek(stack: firstTest, min: 2, max: 2, peek: 2)\n      try assertEqual(2, firstTest.pop())\n    }\n    runTest(\"Test Case 2\") { () throws -> Void in\n      let secondTest = Program.MinMaxStack()\n      secondTest.push(number: 5)\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 5, peek: 5)\n      secondTest.push(number: 5)\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 5, peek: 5)\n      secondTest.push(number: 5)\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 5, peek: 5)\n      secondTest.push(number: 5)\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 5, peek: 5)\n      secondTest.push(number: 8)\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 8, peek: 8)\n      secondTest.push(number: 8)\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 8, peek: 8)\n      secondTest.push(number: 0)\n      try testMinMaxPeek(stack: secondTest, min: 0, max: 8, peek: 0)\n      secondTest.push(number: 8)\n      try testMinMaxPeek(stack: secondTest, min: 0, max: 8, peek: 8)\n      secondTest.push(number: 9)\n      try testMinMaxPeek(stack: secondTest, min: 0, max: 9, peek: 9)\n      secondTest.push(number: 5)\n      try testMinMaxPeek(stack: secondTest, min: 0, max: 9, peek: 5)\n      try assertEqual(5, secondTest.pop())\n      try testMinMaxPeek(stack: secondTest, min: 0, max: 9, peek: 9)\n      try assertEqual(9, secondTest.pop())\n      try testMinMaxPeek(stack: secondTest, min: 0, max: 8, peek: 8)\n      try assertEqual(8, secondTest.pop())\n      try testMinMaxPeek(stack: secondTest, min: 0, max: 8, peek: 0)\n      try assertEqual(0, secondTest.pop())\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 8, peek: 8)\n      try assertEqual(8, secondTest.pop())\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 8, peek: 8)\n      try assertEqual(8, secondTest.pop())\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 5, peek: 5)\n      try assertEqual(5, secondTest.pop())\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 5, peek: 5)\n      try assertEqual(5, secondTest.pop())\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 5, peek: 5)\n      try assertEqual(5, secondTest.pop())\n      try testMinMaxPeek(stack: secondTest, min: 5, max: 5, peek: 5)\n      try assertEqual(5, secondTest.pop())\n    }\n    runTest(\"Test Case 3\") { () throws -> Void in\n      let thirdTest = Program.MinMaxStack()\n      thirdTest.push(number: 2)\n      try testMinMaxPeek(stack: thirdTest, min: 2, max: 2, peek: 2)\n      thirdTest.push(number: 0)\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 2, peek: 0)\n      thirdTest.push(number: 5)\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 5, peek: 5)\n      thirdTest.push(number: 4)\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 5, peek: 4)\n      try assertEqual(4, thirdTest.pop())\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 5, peek: 5)\n      try assertEqual(5, thirdTest.pop())\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 2, peek: 0)\n      thirdTest.push(number: 4)\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 4, peek: 4)\n      thirdTest.push(number: 11)\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 11, peek: 11)\n      thirdTest.push(number: -11)\n      try testMinMaxPeek(stack: thirdTest, min: -11, max: 11, peek: -11)\n      try assertEqual(-11, thirdTest.pop())\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 11, peek: 11)\n      try assertEqual(11, thirdTest.pop())\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 4, peek: 4)\n      try assertEqual(4, thirdTest.pop())\n      try testMinMaxPeek(stack: thirdTest, min: 0, max: 2, peek: 0)\n      try assertEqual(0, thirdTest.pop())\n      try testMinMaxPeek(stack: thirdTest, min: 2, max: 2, peek: 2)\n      try assertEqual(2, thirdTest.pop())\n      thirdTest.push(number: 6)\n      try testMinMaxPeek(stack: thirdTest, min: 6, max: 6, peek: 6)\n      try assertEqual(6, thirdTest.pop())\n    }\n  }\n\n  func testMinMaxPeek(stack: Program.MinMaxStack, min: Int, max: Int, peek: Int) throws {\n    if let stackMin = stack.getMin() {\n      try assertEqual(min, stackMin)\n    }\n\n    if let stackMax = stack.getMax() {\n      try assertEqual(max, stackMax)\n    }\n\n    if let stackPeek = stack.peek() {\n      try assertEqual(peek, stackPeek)\n    }\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let stack = Program.MinMaxStack()\n      stack.push(number: 5)\n      try testMinMaxPeek(stack: stack, min: 5, max: 5, peek: 5)\n      stack.push(number: 7)\n      try testMinMaxPeek(stack: stack, min: 5, max: 7, peek: 7)\n      stack.push(number: 2)\n      try testMinMaxPeek(stack: stack, min: 2, max: 7, peek: 2)\n      try assertEqual(2, stack.pop())\n      try assertEqual(7, stack.pop())\n      try testMinMaxPeek(stack: stack, min: 5, max: 5, peek: 5)\n    }\n  }\n\n  func testMinMaxPeek(stack: Program.MinMaxStack, min: Int, max: Int, peek: Int) throws {\n    if let stackMin = stack.getMin() {\n      try assertEqual(min, stackMin)\n    }\n\n    if let stackMax = stack.getMax() {\n      try assertEqual(max, stackMax)\n    }\n\n    if let stackPeek = stack.peek() {\n      try assertEqual(peek, stackPeek)\n    }\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Program {\n  class MinMaxStack {\n    var minMaxStack = [[String: Int]]()\n    var stack = [Int]()\n\n    // O(1) time | O(1) space\n    func peek() -> Int? {\n      return stack.last\n    }\n\n    // O(1) time | O(1) space\n    func pop() -> Int? {\n      minMaxStack.popLast()\n\n      return stack.popLast()\n    }\n\n    // O(1) time | O(1) space\n    func push(number: Int) {\n      var newMinMax = [\"min\": number, \"max\": number]\n\n      if let lastMinMax = minMaxStack.last {\n        newMinMax[\"min\"] = min(lastMinMax[\"min\"]!, newMinMax[\"min\"]!)\n        newMinMax[\"max\"] = max(lastMinMax[\"max\"]!, newMinMax[\"max\"]!)\n      }\n\n      minMaxStack.append(newMinMax)\n      stack.append(number)\n    }\n\n    // O(1) time | O(1) space\n    func getMin() -> Int? {\n      return minMaxStack.last?[\"min\"]\n    }\n\n    // O(1) | O(1) space\n    func getMax() -> Int? {\n      return minMaxStack.last?[\"max\"]\n    }\n  }\n}\n"
      ]
    },
    "typescript": {
      "Language": "typescript",
      "StartingCode": "// Feel free to add new properties and methods to the class.\nexport class MinMaxStack {\n  peek() {\n    // Write your code here.\n    return -1;\n  }\n\n  pop() {\n    // Write your code here.\n    return -1;\n  }\n\n  push(number: number) {\n    // Write your code here.\n  }\n\n  getMin() {\n    // Write your code here.\n    return -1;\n  }\n\n  getMax() {\n    // Write your code here.\n    return -1;\n  }\n}\n",
      "StartingTest": "",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nfunction testMinMaxPeek(min: number, max: number, peek: number, stack: program.MinMaxStack) {\n  chai.expect(stack.getMin()).to.deep.equal(min);\n  chai.expect(stack.getMax()).to.deep.equal(max);\n  chai.expect(stack.peek()).to.deep.equal(peek);\n}\n\nit('Test Case #1', function () {\n  const stack = new program.MinMaxStack();\n  stack.push(5);\n  testMinMaxPeek(5, 5, 5, stack);\n  stack.push(7);\n  testMinMaxPeek(5, 7, 7, stack);\n  stack.push(2);\n  testMinMaxPeek(2, 7, 2, stack);\n  chai.expect(stack.pop()).to.deep.equal(2);\n  chai.expect(stack.pop()).to.deep.equal(7);\n  testMinMaxPeek(5, 5, 5, stack);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\ninterface MinMaxItem {\n  min: number;\n  max: number;\n}\n\nexport class MinMaxStack {\n  minMaxStack: MinMaxItem[];\n  stack: number[];\n\n  constructor() {\n    this.minMaxStack = [];\n    this.stack = [];\n  }\n\n  // O(1) time | O(1) space\n  peek() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  // O(1) time | O(1) space\n  pop() {\n    this.minMaxStack.pop();\n    return this.stack.pop();\n  }\n\n  // O(1) time | O(1) space\n  push(number: number) {\n    const newMinMax = {min: number, max: number};\n    if (this.minMaxStack.length) {\n      const lastMinMax = this.minMaxStack[this.minMaxStack.length - 1];\n      newMinMax.min = Math.min(lastMinMax.min, number);\n      newMinMax.max = Math.max(lastMinMax.max, number);\n    }\n    this.minMaxStack.push(newMinMax);\n    this.stack.push(number);\n  }\n\n  // O(1) time | O(1) space\n  getMin() {\n    return this.minMaxStack[this.minMaxStack.length - 1].min;\n  }\n\n  // O(1) time | O(1) space\n  getMax() {\n    return this.minMaxStack[this.minMaxStack.length - 1].max;\n  }\n}\n"
      ]
    }
  },
  "JSONTestLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "JSONTests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            7
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            7
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            1
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            3
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            9
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            0
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            8
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            9
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            2
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            0
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            5
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            4
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            4
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            11
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [
            -11
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        },
        {
          "arguments": [
            6
          ],
          "method": "push"
        },
        {
          "arguments": [],
          "method": "getMin"
        },
        {
          "arguments": [],
          "method": "getMax"
        },
        {
          "arguments": [],
          "method": "peek"
        },
        {
          "arguments": [],
          "method": "pop"
        }
      ]
    }
  ],
  "JSONAnswers": [
    [
      [
        {
          "arguments": [
            5
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [
            7
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 7
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 7
        },
        {
          "arguments": [
            2
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 2
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 7
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 2
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 2
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 7
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        }
      ],
      [
        {
          "arguments": [
            2
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 2
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 2
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 2
        },
        {
          "arguments": [
            7
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 2
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 7
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 7
        },
        {
          "arguments": [
            1
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 1
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 7
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 1
        },
        {
          "arguments": [
            8
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 1
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 8
        },
        {
          "arguments": [
            3
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 1
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 3
        },
        {
          "arguments": [
            9
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 1
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 9
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 9
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 9
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 1
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 3
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 3
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 1
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 8
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 8
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 1
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 7
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 1
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 1
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 2
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 7
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 7
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 7
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 2
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 2
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 2
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 2
        }
      ],
      [
        {
          "arguments": [
            5
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [
            5
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [
            5
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [
            5
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [
            8
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 8
        },
        {
          "arguments": [
            8
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 8
        },
        {
          "arguments": [
            0
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 0
        },
        {
          "arguments": [
            8
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 8
        },
        {
          "arguments": [
            9
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 9
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 9
        },
        {
          "arguments": [
            5
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 9
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 9
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 9
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 9
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 8
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 8
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 0
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 8
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 8
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 8
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 8
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 8
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 5
        }
      ],
      [
        {
          "arguments": [
            2
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 2
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 2
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 2
        },
        {
          "arguments": [
            0
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 2
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 0
        },
        {
          "arguments": [
            5
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [
            4
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 4
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 4
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 5
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 5
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 5
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 2
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 0
        },
        {
          "arguments": [
            4
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 4
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 4
        },
        {
          "arguments": [
            11
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 11
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 11
        },
        {
          "arguments": [
            -11
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": -11
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 11
        },
        {
          "arguments": [],
          "method": "peek",
          "output": -11
        },
        {
          "arguments": [],
          "method": "pop",
          "output": -11
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 11
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 11
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 11
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 4
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 4
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 4
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 2
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 0
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 0
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 2
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 2
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 2
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 2
        },
        {
          "arguments": [
            6
          ],
          "method": "push",
          "output": null
        },
        {
          "arguments": [],
          "method": "getMin",
          "output": 6
        },
        {
          "arguments": [],
          "method": "getMax",
          "output": 6
        },
        {
          "arguments": [],
          "method": "peek",
          "output": 6
        },
        {
          "arguments": [],
          "method": "pop",
          "output": 6
        }
      ]
    ]
  ]
}