{
  "Summary": {
    "Name": "Linked List Construction",
    "Category": "Linked Lists",
    "Difficulty": 2,
    "Available": true,
    "Metadata": {
      "date": "2018-10-20T00:00:00Z",
      "number": 251,
      "timeOne": 0,
      "timeTwo": 2101,
      "url": "https://player.vimeo.com/video/293493132"
    }
  },
  "Prompt": "",
  "Hints": "When dealing with linked lists, it's very important to keep track of pointers on nodes (i.e., the \"next\" and \"prev\" properties on the nodes). For instance, if you're inserting a node in a linked list, but that node is already located somewhere else in the linked list (in other words, if you're moving a node), it's crucial to completely update the pointers of the adjacent nodes of the node being moved before updating the node's own pointers. The order in which you update nodes' pointers will make or break your algorithm.\nRealize that the insertBefore() and insertAfter() methods can be used to implement the setHead(), setTail(), and insertAtPosition() methods; making the insertBefore() and insertAfter() methods as robust as possible will simplify your code for the other methods. Make sure to take care of edge cases involving inserting nodes before the head of the linked list or inserting nodes after the tail of the linked list.\nSimilar to Hint #2, realize that the remove() method can be used to implement the removeNodesWithValue() method as well as parts of the insertBefore() and insertAfter() methods; make sure that the remove() method handles edge cases regarding the head and the tail.\n",
  "SpaceTime": "setHead, setTail, insertBefore, insertAfter, and remove: O(1) time | O(1) space\ninsertAtPosition: O(p) time | O(1) space - where p is input position\nremoveNodesWithValue, containsNodeWithValue: O(n) time | O(1) space - where n is the number of nodes in the linked list\n",
  "PromptHTML": "<p>\n  Write a <span>DoublyLinkedList</span> class that has a <span>head</span> and a\n  <span>tail</span>, both of which point to either a linked list\n  <span>Node</span> or <span>None</span> / <span>null</span>. The class should\n  support:\n</p>\n<ul>\n  <li>\n    - Setting the head and tail of the linked list.\n  </li>\n  <li>\n    - Inserting nodes before and after other nodes as well as at given\n    positions.\n  </li>\n  <li>- Removing given nodes and removing nodes with given values;</li>\n  <li>- Searching for nodes with given values.</li>\n</ul>\n<p>\n  Each <span>Node</span> has an integer <span>value</span> as well as a\n  <span>prev</span> node and a <span>next</span> node, both of which can point\n  to either another node or <span>None</span> / <span>null</span>.\n</p>\n<h3>Sample Usage</h3>\n<pre>\n<span class=\"CodeEditor-promptComment\">// Assume the following linked list has already been created:</span>\n1 <-> 2 <-> 3 <-> 4 <-> 5\n<span class=\"CodeEditor-promptParameter\">setHead</span>(4): 4 <-> 1 <-> 2 <-> 3 <-> 5 <span class=\"CodeEditor-promptComment\">// set the existing node with value 4 as the head</span>\n<span class=\"CodeEditor-promptParameter\">setTail</span>(6): 4 <-> 1 <-> 2 <-> 3 <-> 5 <-> 6 <span class=\"CodeEditor-promptComment\">// set the existing node with value 6 as the tail</span>\n<span class=\"CodeEditor-promptParameter\">insertBefore</span>(6, 3): 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <span class=\"CodeEditor-promptComment\">// move the existing node with value 3 before the existing node with value 6</span>\n<span class=\"CodeEditor-promptParameter\">insertAfter</span>(6, 3): 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <-> 3 <span class=\"CodeEditor-promptComment\">// insert a new node with value 3 after the existing node with value 6</span>\n<span class=\"CodeEditor-promptParameter\">insertAtPosition</span>(1, 3): 3 <-> 4 <-> 1 <-> 2 <-> 5 <-> 3 <-> 6 <-> 3 <span class=\"CodeEditor-promptComment\">// insert a new node with value 3 in position 1</span>\n<span class=\"CodeEditor-promptParameter\">removeNodesWithValue</span>(3): 4 <-> 1 <-> 2 <-> 5 <-> 6 <span class=\"CodeEditor-promptComment\">// remove all nodes with value 3</span>\n<span class=\"CodeEditor-promptParameter\">remove</span>(2): 4 <-> 1 <-> 5 <-> 6 <span class=\"CodeEditor-promptComment\">// remove the existing node with value 2</span>\n<span class=\"CodeEditor-promptParameter\">containsNodeWithValue</span>(5): true\n</pre>\n",
  "Notes": "",
  "IsLongOutput": true,
  "Visualization": {
    "inputType": null,
    "outputType": null
  },
  "CustomInputLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "CustomInputVars": [
    {
      "Name": "nodes",
      "Example": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-2",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        },
        {
          "id": "5",
          "next": null,
          "prev": null,
          "value": 5
        },
        {
          "id": "6",
          "next": null,
          "prev": null,
          "value": 6
        }
      ],
      "Schema": {
        "description": "You'll be able to reference these nodes by their <span>id</span>\nin the <span>classMethodsToCall</span>.\n",
        "items": {
          "properties": {
            "id": {
              "type": "string"
            },
            "next": {
              "type": "null"
            },
            "prev": {
              "type": "null"
            },
            "value": {
              "type": "integer"
            }
          },
          "required": [
            "id",
            "value",
            "prev",
            "next"
          ],
          "type": "object"
        },
        "type": "array"
      }
    },
    {
      "Name": "classMethodsToCall",
      "Example": [
        {
          "arguments": [
            "5"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "3"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "6"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "6",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "6",
            "3-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1,
            "3-3"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            3
          ],
          "method": "removeNodesWithValue"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "remove"
        },
        {
          "arguments": [
            5
          ],
          "method": "containsNodeWithValue"
        }
      ],
      "Schema": {
        "description": "These methods will be called in the order that they appear in below\non a <span>DoublyLinkedList</span> and with their respective arguments.\nFor methods that take in actual <span>Node</span>s as parameters, you can\ncreate <span>nodes</span> below and reference them by their <span>id</span>.\n",
        "items": {
          "properties": {
            "arguments": {
              "maxItems": 2,
              "type": "array"
            },
            "method": {
              "enum": [
                "setHead",
                "setTail",
                "insertBefore",
                "insertAfter",
                "insertAtPosition",
                "removeNodesWithValue",
                "remove",
                "containsNodeWithValue"
              ],
              "type": "string"
            }
          },
          "required": [
            "method",
            "arguments"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  ],
  "Resources": {
    "cpp": {
      "Language": "cpp",
      "StartingCode": "using namespace std;\n\nclass Node {\npublic:\n  int value;\n  Node *prev;\n  Node *next;\n\n  Node(int value);\n};\n\n// Feel free to add new properties and methods to the class.\nclass DoublyLinkedList {\npublic:\n  Node *head;\n  Node *tail;\n\n  DoublyLinkedList() {\n    head = NULL;\n    tail = NULL;\n  }\n\n  void setHead(Node *node) {\n    // Write your code here.\n  }\n\n  void setTail(Node *node) {\n    // Write your code here.\n  }\n\n  void insertBefore(Node *node, Node *nodeToInsert) {\n    // Write your code here.\n  }\n\n  void insertAfter(Node *node, Node *nodeToInsert) {\n    // Write your code here.\n  }\n\n  void insertAtPosition(int position, Node *nodeToInsert) {\n    // Write your code here.\n  }\n\n  void removeNodesWithValue(int value) {\n    // Write your code here.\n  }\n\n  void remove(Node *node) {\n    // Write your code here.\n  }\n\n  bool containsNodeWithValue(int value) {\n    // Write your code here.\n    return false;\n  }\n};\n",
      "StartingTest": "#include <vector>\n\nNode::Node(int value) {\n  this->value = value;\n  prev = NULL;\n  next = NULL;\n};\n\n#define expectEmpty(linkedList)                                                \\\n  {                                                                            \\\n    assert(linkedList.head == NULL);                                           \\\n    assert(linkedList.tail == NULL);                                           \\\n  }\n\n#define expectHeadTail(linkedList, node1, node2)                               \\\n  {                                                                            \\\n    assert(linkedList.head == node1);                                          \\\n    assert(linkedList.tail == node2);                                          \\\n  }\n\n#define expectSingleNode(linkedList, node)                                     \\\n  {                                                                            \\\n    assert(linkedList.head == node);                                           \\\n    assert(linkedList.tail == node);                                           \\\n  }\n\nvector<int> getNodeValuesHeadToTail(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node *node = linkedList.head;\n  while (node != NULL) {\n    values.push_back(node->value);\n    node = node->next;\n  }\n  return values;\n}\n\nvector<int> getNodeValuesTailToHead(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node *node = linkedList.tail;\n  while (node != NULL) {\n    values.push_back(node->value);\n    node = node->prev;\n  }\n  return values;\n}\n\nvoid removeNodes(DoublyLinkedList *linkedList, vector<Node *> *nodes) {\n  for (int i = 0; i < nodes->size(); i++) {\n    linkedList->remove(nodes->at(i));\n  }\n}\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n\n    RunTest(\"Test Case 1\", []() {\n      DoublyLinkedList linkedList;\n      Node node(1);\n\n      linkedList.setHead(&node);\n      expectSingleNode(linkedList, &node);\n      linkedList.remove(&node);\n      expectEmpty(linkedList);\n      linkedList.setTail(&node);\n      expectSingleNode(linkedList, &node);\n      linkedList.removeNodesWithValue(1);\n      expectEmpty(linkedList);\n      linkedList.insertAtPosition(1, &node);\n      expectSingleNode(linkedList, &node);\n    });\n\n    RunTest(\"Test Case 2\", []() {\n      DoublyLinkedList linkedList;\n      Node first(1);\n      Node second(2);\n      vector<Node *> nodes = {&first, &second};\n\n      linkedList.setHead(&first);\n      linkedList.setTail(&second);\n      expectHeadTail(linkedList, &first, &second);\n      removeNodes(&linkedList, &nodes);\n      expectEmpty(linkedList);\n      linkedList.setHead(&first);\n      linkedList.insertAfter(&first, &second);\n      expectHeadTail(linkedList, &first, &second);\n      removeNodes(&linkedList, &nodes);\n      linkedList.setHead(&first);\n      linkedList.insertBefore(&first, &second);\n      expectHeadTail(linkedList, &second, &first);\n      removeNodes(&linkedList, &nodes);\n      linkedList.insertAtPosition(1, &first);\n      linkedList.insertAtPosition(2, &second);\n      expectHeadTail(linkedList, &first, &second);\n      removeNodes(&linkedList, &nodes);\n      linkedList.insertAtPosition(2, &first);\n      linkedList.insertAtPosition(1, &second);\n      expectHeadTail(linkedList, &second, &first);\n    });\n\n    RunTest(\"Test Case 3\", []() {\n      DoublyLinkedList linkedList;\n      Node first(1);\n      Node second(2);\n      Node third(3);\n      Node fourth(4);\n\n      linkedList.setHead(&first);\n      assert(linkedList.containsNodeWithValue(1) == true);\n      linkedList.insertAfter(&first, &second);\n      assert(linkedList.containsNodeWithValue(2) == true);\n      linkedList.insertAfter(&second, &third);\n      assert(linkedList.containsNodeWithValue(3) == true);\n      linkedList.insertAfter(&third, &fourth);\n      assert(linkedList.containsNodeWithValue(4) == true);\n      linkedList.removeNodesWithValue(3);\n      assert(linkedList.containsNodeWithValue(3) == false);\n      linkedList.remove(&first);\n      assert(linkedList.containsNodeWithValue(1) == false);\n      linkedList.removeNodesWithValue(4);\n      assert(linkedList.containsNodeWithValue(4) == false);\n      linkedList.remove(&second);\n      assert(linkedList.containsNodeWithValue(2) == false);\n    });\n\n    RunTest(\"Test Case 4\", []() {\n      DoublyLinkedList linkedList;\n      Node first(1);\n      Node second(2);\n      Node third(3);\n      Node fourth(3);\n      Node fifth(3);\n      Node sixth(6);\n      Node seventh(7);\n\n      linkedList.setHead(&first);\n      linkedList.insertAfter(&first, &second);\n      linkedList.insertAfter(&second, &third);\n      linkedList.insertAfter(&third, &fourth);\n      linkedList.insertAfter(&fourth, &fifth);\n      linkedList.insertAfter(&fifth, &sixth);\n      linkedList.insertAfter(&sixth, &seventh);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{1, 2, 3, 3, 3, 6, 7}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{7, 6, 3, 3, 3, 2, 1}));\n      expectHeadTail(linkedList, &first, &seventh);\n      linkedList.remove(&second);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{1, 3, 3, 3, 6, 7}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{7, 6, 3, 3, 3, 1}));\n      expectHeadTail(linkedList, &first, &seventh);\n      linkedList.removeNodesWithValue(1);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{3, 3, 3, 6, 7}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{7, 6, 3, 3, 3}));\n      expectHeadTail(linkedList, &third, &seventh);\n      linkedList.removeNodesWithValue(3);\n      assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{6, 7}));\n      assert(getNodeValuesTailToHead(linkedList) == (vector<int>{7, 6}));\n      expectHeadTail(linkedList, &sixth, &seventh);\n      linkedList.removeNodesWithValue(7);\n      assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{6}));\n      assert(getNodeValuesTailToHead(linkedList) == (vector<int>{6}));\n      expectHeadTail(linkedList, &sixth, &sixth);\n    });\n\n    RunTest(\"Test Case 5\", []() {\n      DoublyLinkedList linkedList;\n      Node first(1);\n      Node second(2);\n      Node third(3);\n      Node fourth(4);\n      Node fifth(5);\n      Node sixth(6);\n      Node seventh(7);\n\n      linkedList.setHead(&first);\n      linkedList.insertAfter(&first, &second);\n      linkedList.insertAfter(&second, &third);\n      linkedList.insertAfter(&third, &fourth);\n      linkedList.insertAfter(&fourth, &fifth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{1, 2, 3, 4, 5}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{5, 4, 3, 2, 1}));\n      expectHeadTail(linkedList, &first, &fifth);\n      linkedList.insertAfter(&third, &fifth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{1, 2, 3, 5, 4}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{4, 5, 3, 2, 1}));\n      expectHeadTail(linkedList, &first, &fourth);\n      linkedList.insertAfter(&third, &first);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{2, 3, 1, 5, 4}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{4, 5, 1, 3, 2}));\n      expectHeadTail(linkedList, &second, &fourth);\n      linkedList.insertAfter(&fifth, &second);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{3, 1, 5, 2, 4}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{4, 2, 5, 1, 3}));\n      expectHeadTail(linkedList, &third, &fourth);\n      linkedList.insertAfter(&second, &first);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{3, 5, 2, 1, 4}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{4, 1, 2, 5, 3}));\n      expectHeadTail(linkedList, &third, &fourth);\n      linkedList.insertAfter(&fourth, &sixth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{3, 5, 2, 1, 4, 6}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{6, 4, 1, 2, 5, 3}));\n      expectHeadTail(linkedList, &third, &sixth);\n      linkedList.insertAfter(&second, &seventh);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{3, 5, 2, 7, 1, 4, 6}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{6, 4, 1, 7, 2, 5, 3}));\n      expectHeadTail(linkedList, &third, &sixth);\n    });\n\n    RunTest(\"Test Case 6\", []() {\n      DoublyLinkedList linkedList;\n      Node first(1);\n      Node second(2);\n      Node third(3);\n      Node fourth(4);\n      Node fifth(5);\n      Node sixth(6);\n      Node seventh(7);\n\n      linkedList.setHead(&first);\n      linkedList.insertBefore(&first, &second);\n      linkedList.insertBefore(&second, &third);\n      linkedList.insertBefore(&third, &fourth);\n      linkedList.insertBefore(&fourth, &fifth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{5, 4, 3, 2, 1}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{1, 2, 3, 4, 5}));\n      expectHeadTail(linkedList, &fifth, &first);\n      linkedList.insertBefore(&third, &first);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{5, 4, 1, 3, 2}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{2, 3, 1, 4, 5}));\n      expectHeadTail(linkedList, &fifth, &second);\n      linkedList.insertBefore(&fifth, &second);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{2, 5, 4, 1, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 1, 4, 5, 2}));\n      expectHeadTail(linkedList, &second, &third);\n      linkedList.insertBefore(&fifth, &fourth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{2, 4, 5, 1, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 1, 5, 4, 2}));\n      expectHeadTail(linkedList, &second, &third);\n      linkedList.insertBefore(&second, &sixth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{6, 2, 4, 5, 1, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 1, 5, 4, 2, 6}));\n      expectHeadTail(linkedList, &sixth, &third);\n      linkedList.insertBefore(&first, &seventh);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{6, 2, 4, 5, 7, 1, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 1, 7, 5, 4, 2, 6}));\n      expectHeadTail(linkedList, &sixth, &third);\n    });\n\n    RunTest(\"Test Case 7\", []() {\n      DoublyLinkedList linkedList;\n      Node first(1);\n      Node second(2);\n      Node third(3);\n      Node fourth(4);\n      Node fifth(5);\n      Node sixth(6);\n      Node seventh(7);\n\n      linkedList.setHead(&first);\n      linkedList.insertAtPosition(1, &second);\n      linkedList.insertAtPosition(1, &third);\n      linkedList.insertAtPosition(1, &fourth);\n      linkedList.insertAtPosition(1, &fifth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{5, 4, 3, 2, 1}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{1, 2, 3, 4, 5}));\n      expectHeadTail(linkedList, &fifth, &first);\n      linkedList.insertAtPosition(2, &first);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{5, 1, 4, 3, 2}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{2, 3, 4, 1, 5}));\n      expectHeadTail(linkedList, &fifth, &second);\n      linkedList.insertAtPosition(1, &second);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{2, 5, 1, 4, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 4, 1, 5, 2}));\n      expectHeadTail(linkedList, &second, &third);\n      linkedList.insertAtPosition(2, &fourth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{2, 4, 5, 1, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 1, 5, 4, 2}));\n      expectHeadTail(linkedList, &second, &third);\n      linkedList.insertAtPosition(1, &sixth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{6, 2, 4, 5, 1, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 1, 5, 4, 2, 6}));\n      expectHeadTail(linkedList, &sixth, &third);\n      linkedList.insertAtPosition(5, &seventh);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{6, 2, 4, 5, 7, 1, 3}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{3, 1, 7, 5, 4, 2, 6}));\n      expectHeadTail(linkedList, &sixth, &third);\n      linkedList.insertAtPosition(8, &fourth);\n      assert(getNodeValuesHeadToTail(linkedList) ==\n             (vector<int>{6, 2, 5, 7, 1, 3, 4}));\n      assert(getNodeValuesTailToHead(linkedList) ==\n             (vector<int>{4, 3, 1, 7, 5, 2, 6}));\n      expectHeadTail(linkedList, &sixth, &fourth);\n    });\n  }\n};\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\n#include <vector>\n\nNode::Node(int value) {\n  this->value = value;\n  prev = NULL;\n  next = NULL;\n};\n\nvector<int> getNodeValuesHeadToTail(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node *node = linkedList.head;\n  while (node != NULL) {\n    values.push_back(node->value);\n    node = node->next;\n  }\n  return values;\n}\n\nvector<int> getNodeValuesTailToHead(DoublyLinkedList linkedList) {\n  vector<int> values = {};\n  Node *node = linkedList.tail;\n  while (node != NULL) {\n    values.push_back(node->value);\n    node = node->prev;\n  }\n  return values;\n}\n\nvoid bindNodes(Node *nodeOne, Node *nodeTwo) {\n  nodeOne->next = nodeTwo;\n  nodeTwo->prev = nodeOne;\n}\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      DoublyLinkedList linkedList;\n       Node one(1);\n       Node two(2);\n       Node three(3);\n       Node three2(3);\n       Node three3(3);\n       Node four(4);\n       Node five(5);\n       Node six(6);\n       bindNodes(&one, &two);\n       bindNodes(&two, &three);\n       bindNodes(&three, &four);\n       bindNodes(&four, &five);\n       linkedList.head = &one;\n       linkedList.tail = &five;\n\n       linkedList.setHead(&four);\n       assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 3, 5}));\n       assert(getNodeValuesTailToHead(linkedList) == (vector<int>{5, 3, 2, 1, 4}));\n       \n       linkedList.setTail(&six);\n       assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 3, 5, 6}));\n       assert(getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 3, 2, 1, 4}));\n       \n       linkedList.insertBefore(&six, &three);\n       assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 5, 3, 6}));\n       assert(getNodeValuesTailToHead(linkedList) == (vector<int>{6, 3, 5, 2, 1, 4}));\n       \n       linkedList.insertAfter(&six, &three2);\n       assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 5, 3, 6, 3}));\n       assert(getNodeValuesTailToHead(linkedList) == (vector<int>{3, 6, 3, 5, 2, 1, 4}));\n       \n       linkedList.insertAtPosition(1, &three3);\n       assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{3, 4, 1, 2, 5, 3, 6, 3}));\n       assert(getNodeValuesTailToHead(linkedList) == (vector<int>{3, 6, 3, 5, 2, 1, 4, 3}));\n       \n       linkedList.removeNodesWithValue(3);\n       assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 2, 5, 6}));\n       assert(getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 2, 1, 4}));\n       \n       linkedList.remove(&two);\n       assert(getNodeValuesHeadToTail(linkedList) == (vector<int>{4, 1, 5, 6}));\n       assert(getNodeValuesTailToHead(linkedList) == (vector<int>{6, 5, 1, 4}));\n\n       assert(linkedList.containsNodeWithValue(5) == true);\n    });\n  }\n};\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nusing namespace std;\n\nclass Node {\npublic:\n  int value;\n  Node *prev;\n  Node *next;\n\n  Node(int value);\n};\n\nclass DoublyLinkedList {\npublic:\n  Node *head;\n  Node *tail;\n\n  DoublyLinkedList() {\n    head = NULL;\n    tail = NULL;\n  }\n\n  // O(1) time | O(1) space\n  void setHead(Node *node) {\n    if (head == NULL) {\n      head = node;\n      tail = node;\n      return;\n    }\n    insertBefore(head, node);\n  }\n\n  // O(1) time | O(1) space\n  void setTail(Node *node) {\n    if (tail == NULL) {\n      setHead(node);\n      return;\n    }\n    insertAfter(tail, node);\n  }\n\n  // O(1) time | O(1) space\n  void insertBefore(Node *node, Node *nodeToInsert) {\n    if (nodeToInsert == head && nodeToInsert == tail)\n      return;\n    remove(nodeToInsert);\n    nodeToInsert->prev = node->prev;\n    nodeToInsert->next = node;\n    if (node->prev == NULL) {\n      head = nodeToInsert;\n    } else {\n      node->prev->next = nodeToInsert;\n    }\n    node->prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  void insertAfter(Node *node, Node *nodeToInsert) {\n    if (nodeToInsert == head && nodeToInsert == tail)\n      return;\n    remove(nodeToInsert);\n    nodeToInsert->prev = node;\n    nodeToInsert->next = node->next;\n    if (node->next == NULL) {\n      tail = nodeToInsert;\n    } else {\n      node->next->prev = nodeToInsert;\n    }\n    node->next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  void insertAtPosition(int position, Node *nodeToInsert) {\n    if (position == 1) {\n      setHead(nodeToInsert);\n      return;\n    }\n    Node *node = head;\n    int currentPosition = 1;\n    while (node != NULL && currentPosition++ != position)\n      node = node->next;\n    if (node != NULL) {\n      insertBefore(node, nodeToInsert);\n    } else {\n      setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  void removeNodesWithValue(int value) {\n    Node *node = head;\n    while (node != NULL) {\n      Node *nodeToRemove = node;\n      node = node->next;\n      if (nodeToRemove->value == value)\n        remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  void remove(Node *node) {\n    if (node == head)\n      head = head->next;\n    if (node == tail)\n      tail = tail->prev;\n    removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  bool containsNodeWithValue(int value) {\n    Node *node = head;\n    while (node != NULL && node->value != value)\n      node = node->next;\n    return node != NULL;\n  }\n\n  void removeNodeBindings(Node *node) {\n    if (node->prev != NULL)\n      node->prev->next = node->next;\n    if (node->next != NULL)\n      node->next->prev = node->prev;\n    node->prev = NULL;\n    node->next = NULL;\n  }\n};\n"
      ]
    },
    "csharp": {
      "Language": "csharp",
      "StartingCode": "// Feel free to add new properties and methods to the class.\npublic class Program {\n\tpublic class DoublyLinkedList {\n\t\tpublic Node Head;\n\t\tpublic Node Tail;\n\n\t\tpublic void SetHead(Node node) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void SetTail(Node node) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void InsertBefore(Node node, Node nodeToInsert) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void InsertAfter(Node node, Node nodeToInsert) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void InsertAtPosition(int position, Node nodeToInsert) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void RemoveNodesWithValue(int value) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic void Remove(Node node) {\n\t\t\t// Write your code here.\n\t\t}\n\n\t\tpublic bool ContainsNodeWithValue(int value) {\n\t\t\t// Write your code here.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Do not edit the class below.\n\tpublic class Node {\n\t\tpublic int Value;\n\t\tpublic Node Prev;\n\t\tpublic Node Next;\n\n\t\tpublic Node(int value) {\n\t\t\tthis.Value = value;\n\t\t}\n\t}\n}\n",
      "StartingTest": "using System.Collections.Generic;\n\npublic class ProgramTest {\n\tprivate void expectEmpty(Program.DoublyLinkedList linkedList) {\n\t\tUtils.AssertTrue(linkedList.Head == null);\n\t\tUtils.AssertTrue(linkedList.Tail == null);\n\t}\n\n\tprivate void expectHeadTail(Program.DoublyLinkedList linkedList, Program.Node Head,\n\t  Program.Node Tail) {\n\t\tUtils.AssertTrue(linkedList.Head == Head);\n\t\tUtils.AssertTrue(linkedList.Tail == Tail);\n\t}\n\n\tprivate void expectSingleNode(Program.DoublyLinkedList linkedList, Program.Node node) {\n\t\tUtils.AssertTrue(linkedList.Head == node);\n\t\tUtils.AssertTrue(linkedList.Tail == node);\n\t}\n\n\tprivate List<int> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList) {\n\t\tList<int> values = new List<int>();\n\t\tProgram.Node node = linkedList.Head;\n\t\twhile (node != null) {\n\t\t\tvalues.Add(node.Value);\n\t\t\tnode = node.Next;\n\t\t}\n\t\treturn values;\n\t}\n\n\tprivate List<int> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList) {\n\t\tList<int> values = new List<int>();\n\t\tProgram.Node node = linkedList.Tail;\n\t\twhile (node != null) {\n\t\t\tvalues.Add(node.Value);\n\t\t\tnode = node.Prev;\n\t\t}\n\t\treturn values;\n\t}\n\n\tprivate void removeNodes(Program.DoublyLinkedList linkedList, List<Program.Node> nodes) {\n\t\tforeach (Program.Node node in nodes) {\n\t\t\tlinkedList.Remove(node);\n\t\t}\n\t}\n\n\tprivate bool compare(List<int> array1, int[] array2) {\n\t\tif (array1.Count != array2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < array1.Count; i++) {\n\t\t\tif (array1[i] != array2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node node = new Program.Node(1);\n\n\t\tlinkedList.SetHead(node);\n\t\texpectSingleNode(linkedList, node);\n\t\tlinkedList.Remove(node);\n\t\texpectEmpty(linkedList);\n\t\tlinkedList.SetTail(node);\n\t\texpectSingleNode(linkedList, node);\n\t\tlinkedList.RemoveNodesWithValue(1);\n\t\texpectEmpty(linkedList);\n\t\tlinkedList.InsertAtPosition(1, node);\n\t\texpectSingleNode(linkedList, node);\n\t}\n\n\t[Test]\n\tpublic void TestCase2() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node first = new Program.Node(1);\n\t\tProgram.Node second = new Program.Node(2);\n\t\tList<Program.Node> nodes = new List<Program.Node>();\n\t\tnodes.Add(first);\n\t\tnodes.Add(second);\n\n\t\tlinkedList.SetHead(first);\n\t\tlinkedList.SetTail(second);\n\t\texpectHeadTail(linkedList, first, second);\n\t\tremoveNodes(linkedList, nodes);\n\t\texpectEmpty(linkedList);\n\t\tlinkedList.SetHead(first);\n\t\tlinkedList.InsertAfter(first, second);\n\t\texpectHeadTail(linkedList, first, second);\n\t\tremoveNodes(linkedList, nodes);\n\t\tlinkedList.SetHead(first);\n\t\tlinkedList.InsertBefore(first, second);\n\t\texpectHeadTail(linkedList, second, first);\n\t\tremoveNodes(linkedList, nodes);\n\t\tlinkedList.InsertAtPosition(1, first);\n\t\tlinkedList.InsertAtPosition(2, second);\n\t\texpectHeadTail(linkedList, first, second);\n\t\tremoveNodes(linkedList, nodes);\n\t\tlinkedList.InsertAtPosition(2, first);\n\t\tlinkedList.InsertAtPosition(1, second);\n\t\texpectHeadTail(linkedList, second, first);\n\t}\n\n\t[Test]\n\tpublic void TestCase3() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node first = new Program.Node(1);\n\t\tProgram.Node second = new Program.Node(2);\n\t\tProgram.Node third = new Program.Node(3);\n\t\tProgram.Node fourth = new Program.Node(4);\n\n\t\tlinkedList.SetHead(first);\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(1) == true);\n\t\tlinkedList.InsertAfter(first, second);\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(2) == true);\n\t\tlinkedList.InsertAfter(second, third);\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(3) == true);\n\t\tlinkedList.InsertAfter(third, fourth);\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(4) == true);\n\t\tlinkedList.RemoveNodesWithValue(3);\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(3) == false);\n\t\tlinkedList.Remove(first);\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(1) == false);\n\t\tlinkedList.RemoveNodesWithValue(4);\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(4) == false);\n\t\tlinkedList.Remove(second);\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(2) == false);\n\t}\n\n\t[Test]\n\tpublic void TestCase4() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node first = new Program.Node(1);\n\t\tProgram.Node second = new Program.Node(2);\n\t\tProgram.Node third = new Program.Node(3);\n\t\tProgram.Node fourth = new Program.Node(3);\n\t\tProgram.Node fifth = new Program.Node(3);\n\t\tProgram.Node sixth = new Program.Node(6);\n\t\tProgram.Node seventh = new Program.Node(7);\n\n\t\tlinkedList.SetHead(first);\n\t\tlinkedList.InsertAfter(first, second);\n\t\tlinkedList.InsertAfter(second, third);\n\t\tlinkedList.InsertAfter(third, fourth);\n\t\tlinkedList.InsertAfter(fourth, fifth);\n\t\tlinkedList.InsertAfter(fifth, sixth);\n\t\tlinkedList.InsertAfter(sixth, seventh);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {1, 2, 3, 3, 3, 6, 7}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {7, 6, 3, 3, 3, 2, 1}));\n\t\texpectHeadTail(linkedList, first, seventh);\n\t\tlinkedList.Remove(second);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {1, 3, 3, 3, 6, 7}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {7, 6, 3, 3, 3, 1}));\n\t\texpectHeadTail(linkedList, first, seventh);\n\t\tlinkedList.RemoveNodesWithValue(1);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {3, 3, 3, 6, 7}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {7, 6, 3, 3, 3}));\n\t\texpectHeadTail(linkedList, third, seventh);\n\t\tlinkedList.RemoveNodesWithValue(3);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {6, 7}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {7, 6}));\n\t\texpectHeadTail(linkedList, sixth, seventh);\n\t\tlinkedList.RemoveNodesWithValue(7);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6}));\n\t\texpectHeadTail(linkedList, sixth, sixth);\n\t}\n\n\t[Test]\n\tpublic void TestCase5() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node first = new Program.Node(1);\n\t\tProgram.Node second = new Program.Node(2);\n\t\tProgram.Node third = new Program.Node(3);\n\t\tProgram.Node fourth = new Program.Node(4);\n\t\tProgram.Node fifth = new Program.Node(5);\n\t\tProgram.Node sixth = new Program.Node(6);\n\t\tProgram.Node seventh = new Program.Node(7);\n\n\t\tlinkedList.SetHead(first);\n\t\tlinkedList.InsertAfter(first, second);\n\t\tlinkedList.InsertAfter(second, third);\n\t\tlinkedList.InsertAfter(third, fourth);\n\t\tlinkedList.InsertAfter(fourth, fifth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {1, 2, 3, 4, 5}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {5, 4, 3, 2, 1}));\n\t\texpectHeadTail(linkedList, first, fifth);\n\t\tlinkedList.InsertAfter(third, fifth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {1, 2, 3, 5, 4}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {4, 5, 3, 2, 1}));\n\t\texpectHeadTail(linkedList, first, fourth);\n\t\tlinkedList.InsertAfter(third, first);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {2, 3, 1, 5, 4}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {4, 5, 1, 3, 2}));\n\t\texpectHeadTail(linkedList, second, fourth);\n\t\tlinkedList.InsertAfter(fifth, second);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {3, 1, 5, 2, 4}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {4, 2, 5, 1, 3}));\n\t\texpectHeadTail(linkedList, third, fourth);\n\t\tlinkedList.InsertAfter(second, first);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {3, 5, 2, 1, 4}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 3}));\n\t\texpectHeadTail(linkedList, third, fourth);\n\t\tlinkedList.InsertAfter(fourth, sixth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {3, 5, 2, 1, 4, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 4, 1, 2, 5, 3}));\n\t\texpectHeadTail(linkedList, third, sixth);\n\t\tlinkedList.InsertAfter(second, seventh);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {3, 5, 2, 7, 1, 4, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 4, 1, 7, 2, 5, 3}));\n\t\texpectHeadTail(linkedList, third, sixth);\n\t}\n\n\t[Test]\n\tpublic void TestCase6() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node first = new Program.Node(1);\n\t\tProgram.Node second = new Program.Node(2);\n\t\tProgram.Node third = new Program.Node(3);\n\t\tProgram.Node fourth = new Program.Node(4);\n\t\tProgram.Node fifth = new Program.Node(5);\n\t\tProgram.Node sixth = new Program.Node(6);\n\t\tProgram.Node seventh = new Program.Node(7);\n\n\t\tlinkedList.SetHead(first);\n\t\tlinkedList.InsertBefore(first, second);\n\t\tlinkedList.InsertBefore(second, third);\n\t\tlinkedList.InsertBefore(third, fourth);\n\t\tlinkedList.InsertBefore(fourth, fifth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {5, 4, 3, 2, 1}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {1, 2, 3, 4, 5}));\n\t\texpectHeadTail(linkedList, fifth, first);\n\t\tlinkedList.InsertBefore(third, first);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {5, 4, 1, 3, 2}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {2, 3, 1, 4, 5}));\n\t\texpectHeadTail(linkedList, fifth, second);\n\t\tlinkedList.InsertBefore(fifth, second);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {2, 5, 4, 1, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 1, 4, 5, 2}));\n\t\texpectHeadTail(linkedList, second, third);\n\t\tlinkedList.InsertBefore(fifth, fourth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {2, 4, 5, 1, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 1, 5, 4, 2}));\n\t\texpectHeadTail(linkedList, second, third);\n\t\tlinkedList.InsertBefore(second, sixth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {6, 2, 4, 5, 1, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 1, 5, 4, 2, 6}));\n\t\texpectHeadTail(linkedList, sixth, third);\n\t\tlinkedList.InsertBefore(first, seventh);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {6, 2, 4, 5, 7, 1, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 1, 7, 5, 4, 2, 6}));\n\t\texpectHeadTail(linkedList, sixth, third);\n\t}\n\n\t[Test]\n\tpublic void TestCase7() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node first = new Program.Node(1);\n\t\tProgram.Node second = new Program.Node(2);\n\t\tProgram.Node third = new Program.Node(3);\n\t\tProgram.Node fourth = new Program.Node(4);\n\t\tProgram.Node fifth = new Program.Node(5);\n\t\tProgram.Node sixth = new Program.Node(6);\n\t\tProgram.Node seventh = new Program.Node(7);\n\n\t\tlinkedList.SetHead(first);\n\t\tlinkedList.InsertAtPosition(1, second);\n\t\tlinkedList.InsertAtPosition(1, third);\n\t\tlinkedList.InsertAtPosition(1, fourth);\n\t\tlinkedList.InsertAtPosition(1, fifth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {5, 4, 3, 2, 1}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {1, 2, 3, 4, 5}));\n\t\texpectHeadTail(linkedList, fifth, first);\n\t\tlinkedList.InsertAtPosition(2, first);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {5, 1, 4, 3, 2}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {2, 3, 4, 1, 5}));\n\t\texpectHeadTail(linkedList, fifth, second);\n\t\tlinkedList.InsertAtPosition(1, second);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {2, 5, 1, 4, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 4, 1, 5, 2}));\n\t\texpectHeadTail(linkedList, second, third);\n\t\tlinkedList.InsertAtPosition(2, fourth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {2, 4, 5, 1, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 1, 5, 4, 2}));\n\t\texpectHeadTail(linkedList, second, third);\n\t\tlinkedList.InsertAtPosition(1, sixth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {6, 2, 4, 5, 1, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 1, 5, 4, 2, 6}));\n\t\texpectHeadTail(linkedList, sixth, third);\n\t\tlinkedList.InsertAtPosition(5, seventh);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {6, 2, 4, 5, 7, 1, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 1, 7, 5, 4, 2, 6}));\n\t\texpectHeadTail(linkedList, sixth, third);\n\t\tlinkedList.InsertAtPosition(8, fourth);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {6, 2, 5, 7, 1, 3, 4}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {4, 3, 1, 7, 5, 2, 6}));\n\t\texpectHeadTail(linkedList, sixth, fourth);\n\t}\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\tprivate List<int> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList) {\n\t\tList<int> values = new List<int>();\n\t\tProgram.Node node = linkedList.Head;\n\t\twhile (node != null) {\n\t\t\tvalues.Add(node.Value);\n\t\t\tnode = node.Next;\n\t\t}\n\t\treturn values;\n\t}\n\n\tprivate List<int> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList) {\n\t\tList<int> values = new List<int>();\n\t\tProgram.Node node = linkedList.Tail;\n\t\twhile (node != null) {\n\t\t\tvalues.Add(node.Value);\n\t\t\tnode = node.Prev;\n\t\t}\n\t\treturn values;\n\t}\n\n\tprivate void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n\t\tnodeOne.Next = nodeTwo;\n\t\tnodeTwo.Prev = nodeOne;\n\t}\n\n\tprivate bool compare(List<int> array1, int[] array2) {\n\t\tif (array1.Count != array2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < array1.Count; i++) {\n\t\t\tif (array1[i] != array2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t[Test]\n\tpublic void TestCase1() {\n\t\tProgram.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n\t\tProgram.Node one = new Program.Node(1);\n\t\tProgram.Node two = new Program.Node(2);\n\t\tProgram.Node three = new Program.Node(3);\n\t\tProgram.Node three2 = new Program.Node(3);\n\t\tProgram.Node three3 = new Program.Node(3);\n\t\tProgram.Node four = new Program.Node(4);\n\t\tProgram.Node five = new Program.Node(5);\n\t\tProgram.Node six = new Program.Node(6);\n\t\tbindNodes(one, two);\n\t\tbindNodes(two, three);\n\t\tbindNodes(three, four);\n\t\tbindNodes(four, five);\n\t\tlinkedList.Head = one;\n\t\tlinkedList.Tail = five;\n\n\t\tlinkedList.SetHead(four);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 3, 5}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {5, 3, 2, 1, 4}));\n\n\t\tlinkedList.SetTail(six);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 3, 5, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 5, 3, 2, 1, 4}));\n\n\t\tlinkedList.InsertBefore(six, three);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 3, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 3, 5, 2, 1, 4}));\n\n\t\tlinkedList.InsertAfter(six, three2);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 3, 6, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 6, 3, 5, 2, 1, 4}));\n\n\t\tlinkedList.InsertAtPosition(1, three3);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {3, 4, 1, 2, 5, 3, 6, 3}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {3, 6, 3, 5, 2, 1, 4, 3}));\n\n\t\tlinkedList.RemoveNodesWithValue(3);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(linkedList),\n\t\t  new int[] {4, 1, 2, 5, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(linkedList),\n\t\t  new int[] {6, 5, 2, 1, 4}));\n\n\t\tlinkedList.Remove(two);\n\t\tUtils.AssertTrue(compare(getNodeValuesHeadToTail(\n\t\t\t  linkedList), new int[] {4, 1, 5, 6}));\n\t\tUtils.AssertTrue(compare(getNodeValuesTailToHead(\n\t\t\t  linkedList), new int[] {6, 5, 1, 4}));\n\n\t\tUtils.AssertTrue(linkedList.ContainsNodeWithValue(5));\n\t}\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\npublic class Program {\n\tpublic class DoublyLinkedList {\n\t\tpublic Node Head;\n\t\tpublic Node Tail;\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void SetHead(Node node) {\n\t\t\tif (Head == null) {\n\t\t\t\tHead = node;\n\t\t\t\tTail = node;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tInsertBefore(Head, node);\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void SetTail(Node node) {\n\t\t\tif (Tail == null) {\n\t\t\t\tSetHead(node);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tInsertAfter(Tail, node);\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void InsertBefore(Node node, Node nodeToInsert) {\n\t\t\tif (nodeToInsert == Head && nodeToInsert == Tail) return;\n\t\t\tRemove(nodeToInsert);\n\t\t\tnodeToInsert.Prev = node.Prev;\n\t\t\tnodeToInsert.Next = node;\n\t\t\tif (node.Prev == null) {\n\t\t\t\tHead = nodeToInsert;\n\t\t\t} else {\n\t\t\t\tnode.Prev.Next = nodeToInsert;\n\t\t\t}\n\t\t\tnode.Prev = nodeToInsert;\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void InsertAfter(Node node, Node nodeToInsert) {\n\t\t\tif (nodeToInsert == Head && nodeToInsert == Tail) return;\n\t\t\tRemove(nodeToInsert);\n\t\t\tnodeToInsert.Prev = node;\n\t\t\tnodeToInsert.Next = node.Next;\n\t\t\tif (node.Next == null) {\n\t\t\t\tTail = nodeToInsert;\n\t\t\t} else {\n\t\t\t\tnode.Next.Prev = nodeToInsert;\n\t\t\t}\n\t\t\tnode.Next = nodeToInsert;\n\t\t}\n\n\t\t// O(p) time | O(1) space\n\t\tpublic void InsertAtPosition(int position, Node nodeToInsert) {\n\t\t\tif (position == 1) {\n\t\t\t\tSetHead(nodeToInsert);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tNode node = Head;\n\t\t\tint currentPosition = 1;\n\t\t\twhile (node != null && currentPosition++ != position) node = node.Next;\n\t\t\tif (node != null) {\n\t\t\t\tInsertBefore(node, nodeToInsert);\n\t\t\t} else {\n\t\t\t\tSetTail(nodeToInsert);\n\t\t\t}\n\t\t}\n\n\t\t// O(n) time | O(1) space\n\t\tpublic void RemoveNodesWithValue(int value) {\n\t\t\tNode node = Head;\n\t\t\twhile (node != null) {\n\t\t\t\tNode nodeToRemove = node;\n\t\t\t\tnode = node.Next;\n\t\t\t\tif (nodeToRemove.Value == value) Remove(nodeToRemove);\n\t\t\t}\n\t\t}\n\n\t\t// O(1) time | O(1) space\n\t\tpublic void Remove(Node node) {\n\t\t\tif (node == Head) Head = Head.Next;\n\t\t\tif (node == Tail) Tail = Tail.Prev;\n\t\t\tRemoveNodeBindings(node);\n\t\t}\n\n\t\t// O(n) time | O(1) space\n\t\tpublic bool ContainsNodeWithValue(int value) {\n\t\t\tNode node = Head;\n\t\t\twhile (node != null && node.Value != value) node = node.Next;\n\t\t\treturn node != null;\n\t\t}\n\n\t\tpublic void RemoveNodeBindings(Node node) {\n\t\t\tif (node.Prev != null) node.Prev.Next = node.Next;\n\t\t\tif (node.Next != null) node.Next.Prev = node.Prev;\n\t\t\tnode.Prev = null;\n\t\t\tnode.Next = null;\n\t\t}\n\t}\n\n\tpublic class Node {\n\t\tpublic int Value;\n\t\tpublic Node Prev;\n\t\tpublic Node Next;\n\n\t\tpublic Node(int value) {\n\t\t\tthis.Value = value;\n\t\t}\n\t}\n}\n"
      ]
    },
    "go": {
      "Language": "go",
      "StartingCode": "// Feel free to add methods and fields to the struct definitions.\npackage main\n\ntype Node struct {\n\tValue      int\n\tPrev, Next *Node\n}\n\ntype DoublyLinkedList struct {\n\tHead, Tail *Node\n}\n\nfunc NewDoublyLinkedList() *DoublyLinkedList {\n\t// Write your code here.\n\treturn nil\n}\n\nfunc (ll *DoublyLinkedList) SetHead(node *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) SetTail(node *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) InsertBefore(node, nodeToInsert *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) InsertAfter(node, nodeToInsert *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) InsertAtPosition(position int, nodeToInsert *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) RemoveNodesWithValue(value int) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) Remove(node *Node) {\n\t// Write your code here.\n}\n\nfunc (ll *DoublyLinkedList) ContainsNodeWithValue(value int) bool {\n\t// Write your code here.\n\treturn false\n}\n",
      "StartingTest": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tnode := NewNode(1)\n\n\tlinkedList.SetHead(node)\n\texpectSingleNode(t, linkedList, node)\n\tlinkedList.Remove(node)\n\texpectEmpty(t, linkedList)\n\tlinkedList.SetTail(node)\n\texpectSingleNode(t, linkedList, node)\n\tlinkedList.RemoveNodesWithValue(1)\n\texpectEmpty(t, linkedList)\n\tlinkedList.InsertAtPosition(1, node)\n\texpectSingleNode(t, linkedList, node)\n}\n\nfunc (s *TestSuite) TestCase2(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tfirst := NewNode(1)\n\tsecond := NewNode(2)\n\tnodes := []*Node{first, second}\n\n\tlinkedList.SetHead(first)\n\tlinkedList.SetTail(second)\n\texpectHeadTail(t, linkedList, first, second)\n\tremoveNodes(linkedList, nodes)\n\texpectEmpty(t, linkedList)\n\tlinkedList.SetHead(first)\n\tlinkedList.InsertAfter(first, second)\n\texpectHeadTail(t, linkedList, first, second)\n\tremoveNodes(linkedList, nodes)\n\tlinkedList.SetHead(first)\n\tlinkedList.InsertBefore(first, second)\n\texpectHeadTail(t, linkedList, second, first)\n\tremoveNodes(linkedList, nodes)\n\tlinkedList.InsertAtPosition(1, first)\n\tlinkedList.InsertAtPosition(2, second)\n\texpectHeadTail(t, linkedList, first, second)\n\tremoveNodes(linkedList, nodes)\n\tlinkedList.InsertAtPosition(2, first)\n\tlinkedList.InsertAtPosition(1, second)\n\texpectHeadTail(t, linkedList, second, first)\n}\n\nfunc (s *TestSuite) TestCase3(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tfirst := NewNode(1)\n\tsecond := NewNode(2)\n\tthird := NewNode(3)\n\tfourth := NewNode(4)\n\n\tlinkedList.SetHead(first)\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(1), true)\n\tlinkedList.InsertAfter(first, second)\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(2), true)\n\tlinkedList.InsertAfter(second, third)\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(3), true)\n\tlinkedList.InsertAfter(third, fourth)\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(4), true)\n\tlinkedList.RemoveNodesWithValue(3)\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(3), false)\n\tlinkedList.Remove(first)\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(1), false)\n\tlinkedList.RemoveNodesWithValue(4)\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(4), false)\n\tlinkedList.Remove(second)\n\trequire.Equal(t, linkedList.ContainsNodeWithValue(2), false)\n}\n\nfunc (s *TestSuite) TestCase4(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tfirst := NewNode(1)\n\tsecond := NewNode(2)\n\tthird := NewNode(3)\n\tfourth := NewNode(3)\n\tfifth := NewNode(3)\n\tsixth := NewNode(6)\n\tseventh := NewNode(7)\n\n\tlinkedList.SetHead(first)\n\tlinkedList.InsertAfter(first, second)\n\tlinkedList.InsertAfter(second, third)\n\tlinkedList.InsertAfter(third, fourth)\n\tlinkedList.InsertAfter(fourth, fifth)\n\tlinkedList.InsertAfter(fifth, sixth)\n\tlinkedList.InsertAfter(sixth, seventh)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{1, 2, 3, 3, 3, 6, 7})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{7, 6, 3, 3, 3, 2, 1})\n\texpectHeadTail(t, linkedList, first, seventh)\n\tlinkedList.Remove(second)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{1, 3, 3, 3, 6, 7})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{7, 6, 3, 3, 3, 1})\n\texpectHeadTail(t, linkedList, first, seventh)\n\tlinkedList.RemoveNodesWithValue(1)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{3, 3, 3, 6, 7})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{7, 6, 3, 3, 3})\n\texpectHeadTail(t, linkedList, third, seventh)\n\tlinkedList.RemoveNodesWithValue(3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{6, 7})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{7, 6})\n\texpectHeadTail(t, linkedList, sixth, seventh)\n\tlinkedList.RemoveNodesWithValue(7)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6})\n\texpectHeadTail(t, linkedList, sixth, sixth)\n}\n\nfunc (s *TestSuite) TestCase5(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tfirst := NewNode(1)\n\tsecond := NewNode(2)\n\tthird := NewNode(3)\n\tfourth := NewNode(4)\n\tfifth := NewNode(5)\n\tsixth := NewNode(6)\n\tseventh := NewNode(7)\n\n\tlinkedList.SetHead(first)\n\tlinkedList.InsertAfter(first, second)\n\tlinkedList.InsertAfter(second, third)\n\tlinkedList.InsertAfter(third, fourth)\n\tlinkedList.InsertAfter(fourth, fifth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{1, 2, 3, 4, 5})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{5, 4, 3, 2, 1})\n\texpectHeadTail(t, linkedList, first, fifth)\n\tlinkedList.InsertAfter(third, fifth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{1, 2, 3, 5, 4})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{4, 5, 3, 2, 1})\n\texpectHeadTail(t, linkedList, first, fourth)\n\tlinkedList.InsertAfter(third, first)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{2, 3, 1, 5, 4})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{4, 5, 1, 3, 2})\n\texpectHeadTail(t, linkedList, second, fourth)\n\tlinkedList.InsertAfter(fifth, second)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{3, 1, 5, 2, 4})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{4, 2, 5, 1, 3})\n\texpectHeadTail(t, linkedList, third, fourth)\n\tlinkedList.InsertAfter(second, first)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{3, 5, 2, 1, 4})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{4, 1, 2, 5, 3})\n\texpectHeadTail(t, linkedList, third, fourth)\n\tlinkedList.InsertAfter(fourth, sixth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{3, 5, 2, 1, 4, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 4, 1, 2, 5, 3})\n\texpectHeadTail(t, linkedList, third, sixth)\n\tlinkedList.InsertAfter(second, seventh)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{3, 5, 2, 7, 1, 4, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{6, 4, 1, 7, 2, 5, 3})\n\texpectHeadTail(t, linkedList, third, sixth)\n}\n\nfunc (s *TestSuite) TestCase6(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tfirst := NewNode(1)\n\tsecond := NewNode(2)\n\tthird := NewNode(3)\n\tfourth := NewNode(4)\n\tfifth := NewNode(5)\n\tsixth := NewNode(6)\n\tseventh := NewNode(7)\n\n\tlinkedList.SetHead(first)\n\tlinkedList.InsertBefore(first, second)\n\tlinkedList.InsertBefore(second, third)\n\tlinkedList.InsertBefore(third, fourth)\n\tlinkedList.InsertBefore(fourth, fifth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{5, 4, 3, 2, 1})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{1, 2, 3, 4, 5})\n\texpectHeadTail(t, linkedList, fifth, first)\n\tlinkedList.InsertBefore(third, first)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{5, 4, 1, 3, 2})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{2, 3, 1, 4, 5})\n\texpectHeadTail(t, linkedList, fifth, second)\n\tlinkedList.InsertBefore(fifth, second)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{2, 5, 4, 1, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 1, 4, 5, 2})\n\texpectHeadTail(t, linkedList, second, third)\n\tlinkedList.InsertBefore(fifth, fourth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{2, 4, 5, 1, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 1, 5, 4, 2})\n\texpectHeadTail(t, linkedList, second, third)\n\tlinkedList.InsertBefore(second, sixth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{6, 2, 4, 5, 1, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 1, 5, 4, 2, 6})\n\texpectHeadTail(t, linkedList, sixth, third)\n\tlinkedList.InsertBefore(first, seventh)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{6, 2, 4, 5, 7, 1, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 1, 7, 5, 4, 2, 6})\n\texpectHeadTail(t, linkedList, sixth, third)\n\n}\n\nfunc (s *TestSuite) TestCase7(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tfirst := NewNode(1)\n\tsecond := NewNode(2)\n\tthird := NewNode(3)\n\tfourth := NewNode(4)\n\tfifth := NewNode(5)\n\tsixth := NewNode(6)\n\tseventh := NewNode(7)\n\n\tlinkedList.SetHead(first)\n\tlinkedList.InsertAtPosition(1, second)\n\tlinkedList.InsertAtPosition(1, third)\n\tlinkedList.InsertAtPosition(1, fourth)\n\tlinkedList.InsertAtPosition(1, fifth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{5, 4, 3, 2, 1})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{1, 2, 3, 4, 5})\n\texpectHeadTail(t, linkedList, fifth, first)\n\tlinkedList.InsertAtPosition(2, first)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{5, 1, 4, 3, 2})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{2, 3, 4, 1, 5})\n\texpectHeadTail(t, linkedList, fifth, second)\n\tlinkedList.InsertAtPosition(1, second)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{2, 5, 1, 4, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 4, 1, 5, 2})\n\texpectHeadTail(t, linkedList, second, third)\n\tlinkedList.InsertAtPosition(2, fourth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{2, 4, 5, 1, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 1, 5, 4, 2})\n\texpectHeadTail(t, linkedList, second, third)\n\tlinkedList.InsertAtPosition(1, sixth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{6, 2, 4, 5, 1, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 1, 5, 4, 2, 6})\n\texpectHeadTail(t, linkedList, sixth, third)\n\tlinkedList.InsertAtPosition(5, seventh)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{6, 2, 4, 5, 7, 1, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{3, 1, 7, 5, 4, 2, 6})\n\texpectHeadTail(t, linkedList, sixth, third)\n\tlinkedList.InsertAtPosition(8, fourth)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int{6, 2, 5, 7, 1, 3, 4})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int{4, 3, 1, 7, 5, 2, 6})\n\texpectHeadTail(t, linkedList, sixth, fourth)\n}\n\nfunc NewNode(value int) *Node { return &Node{Value: value} }\n\nfunc expectEmpty(t *TestCase, ll *DoublyLinkedList) {\n\tt.Helper()\n\tif ll.Head != nil {\n\t\tt.Fail()\n\t}\n\tif ll.Tail != nil {\n\t\tt.Fail()\n\t}\n}\n\nfunc expectHeadTail(t *TestCase, ll *DoublyLinkedList, head *Node, tail *Node) {\n\tt.Helper()\n\tif ll.Head != head {\n\t\tt.Fail()\n\t}\n\tif ll.Tail != tail {\n\t\tt.Fail()\n\t}\n}\n\nfunc expectSingleNode(t *TestCase, ll *DoublyLinkedList, node *Node) {\n\tt.Helper()\n\tif ll.Head != node {\n\t\tt.Fail()\n\t}\n\tif ll.Tail != node {\n\t\tt.Fail()\n\t}\n}\n\nfunc getNodeValuesHeadToTail(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Head\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Next\n\t}\n\treturn values\n}\n\nfunc getNodeValuesTailToHead(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Tail\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Prev\n\t}\n\treturn values\n}\n\nfunc removeNodes(ll *DoublyLinkedList, nodes []*Node) {\n\tfor _, node := range nodes {\n\t\tll.Remove(node)\n\t}\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\tlinkedList := NewDoublyLinkedList()\n\tone := NewNode(1)\n\ttwo := NewNode(2)\n\tthree := NewNode(3)\n\tthree2 := NewNode(3)\n\tthree3 := NewNode(3)\n\tfour := NewNode(4)\n\tfive := NewNode(5)\n\tsix := NewNode(6)\n\tbindNodes(one, two)\n\tbindNodes(two, three)\n\tbindNodes(three, four)\n\tbindNodes(four, five)\n\tlinkedList.Head = one\n\tlinkedList.Tail = five\n  \n\tlinkedList.SetHead(four)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int {4, 1, 2, 3, 5})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int {5, 3, 2, 1, 4})\n\t\n\tlinkedList.SetTail(six)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int {4, 1, 2, 3, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int {6, 5, 3, 2, 1, 4})\n\t\n\tlinkedList.InsertBefore(six, three)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int {4, 1, 2, 5, 3, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int {6, 3, 5, 2, 1, 4})\n\t\n\tlinkedList.InsertAfter(six, three2)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int {4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int {3, 6, 3, 5, 2, 1, 4})\n\t\n\tlinkedList.InsertAtPosition(1, three3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int {3, 4, 1, 2, 5, 3, 6, 3})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int {3, 6, 3, 5, 2, 1, 4, 3})\n\t\n\tlinkedList.RemoveNodesWithValue(3)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int {4, 1, 2, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int {6, 5, 2, 1, 4})\n\t\n\tlinkedList.Remove(two)\n\trequire.Equal(t, getNodeValuesHeadToTail(linkedList), []int {4, 1, 5, 6})\n\trequire.Equal(t, getNodeValuesTailToHead(linkedList), []int {6, 5, 1, 4})\n  \n\trequire.Equal(t, linkedList.ContainsNodeWithValue(5), true)\n}\n\nfunc NewNode(value int) *Node { return &Node{Value: value} }\n\nfunc getNodeValuesHeadToTail(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Head\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Next\n\t}\n\treturn values\n}\n\nfunc getNodeValuesTailToHead(ll *DoublyLinkedList) []int {\n\tvalues := []int{}\n\tnode := ll.Tail\n\tfor node != nil {\n\t\tvalues = append(values, node.Value)\n\t\tnode = node.Prev\n\t}\n\treturn values\n}\n\nfunc bindNodes(nodeOne *Node, nodeTwo *Node) {\n\tnodeOne.Next = nodeTwo\n\tnodeTwo.Prev = nodeOne\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\npackage main\n\ntype Node struct {\n\tValue      int\n\tPrev, Next *Node\n}\n\ntype DoublyLinkedList struct {\n\tHead, Tail *Node\n}\n\nfunc NewDoublyLinkedList() *DoublyLinkedList {\n\treturn &DoublyLinkedList{}\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) SetHead(node *Node) {\n\tif ll.Head == nil {\n\t\tll.Head = node\n\t\tll.Tail = node\n\t\treturn\n\t}\n\tll.InsertBefore(ll.Head, node)\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) SetTail(node *Node) {\n\tif ll.Tail == nil {\n\t\tll.SetHead(node)\n\t\treturn\n\t}\n\tll.InsertAfter(ll.Tail, node)\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) InsertBefore(node, nodeToInsert *Node) {\n\tif nodeToInsert == ll.Head && nodeToInsert == ll.Tail {\n\t\treturn\n\t}\n\tll.Remove(nodeToInsert)\n\tnodeToInsert.Prev = node.Prev\n\tnodeToInsert.Next = node\n\tif node.Prev == nil {\n\t\tll.Head = nodeToInsert\n\t} else {\n\t\tnode.Prev.Next = nodeToInsert\n\t}\n\tnode.Prev = nodeToInsert\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) InsertAfter(node, nodeToInsert *Node) {\n\tif nodeToInsert == ll.Head && nodeToInsert == ll.Tail {\n\t\treturn\n\t}\n\tll.Remove(nodeToInsert)\n\tnodeToInsert.Prev = node\n\tnodeToInsert.Next = node.Next\n\tif node.Next == nil {\n\t\tll.Tail = nodeToInsert\n\t} else {\n\t\tnode.Next.Prev = nodeToInsert\n\t}\n\tnode.Next = nodeToInsert\n}\n\n// O(p) time | O(1) space\nfunc (ll *DoublyLinkedList) InsertAtPosition(position int, nodeToInsert *Node) {\n\tif position == 1 {\n\t\tll.SetHead(nodeToInsert)\n\t\treturn\n\t}\n\tnode := ll.Head\n\tcurrentPosition := 1\n\tfor node != nil && currentPosition != position {\n\t\tnode = node.Next\n\t\tcurrentPosition += 1\n\t}\n\tif node != nil {\n\t\tll.InsertBefore(node, nodeToInsert)\n\t} else {\n\t\tll.SetTail(nodeToInsert)\n\t}\n}\n\n// O(n) time | O(1) space\nfunc (ll *DoublyLinkedList) RemoveNodesWithValue(value int) {\n\tnode := ll.Head\n\tfor node != nil {\n\t\tnodeToRemove := node\n\t\tnode = node.Next\n\t\tif nodeToRemove.Value == value {\n\t\t\tll.Remove(nodeToRemove)\n\t\t}\n\t}\n}\n\n// O(1) time | O(1) space\nfunc (ll *DoublyLinkedList) Remove(node *Node) {\n\tif node == ll.Head {\n\t\tll.Head = ll.Head.Next\n\t}\n\tif node == ll.Tail {\n\t\tll.Tail = ll.Tail.Prev\n\t}\n\tll.removeNodeBindings(node)\n}\n\n// O(n) time | O(1) space\nfunc (ll *DoublyLinkedList) ContainsNodeWithValue(value int) bool {\n\tnode := ll.Head\n\tfor node != nil && node.Value != value {\n\t\tnode = node.Next\n\t}\n\treturn node != nil\n}\n\nfunc (ll *DoublyLinkedList) removeNodeBindings(node *Node) {\n\tif node.Prev != nil {\n\t\tnode.Prev.Next = node.Next\n\t}\n\tif node.Next != nil {\n\t\tnode.Next.Prev = node.Prev\n\t}\n\tnode.Prev = nil\n\tnode.Next = nil\n}\n"
      ]
    },
    "java": {
      "Language": "java",
      "StartingCode": "import java.util.*;\n\n// Feel free to add new properties and methods to the class.\nclass Program {\n  static class DoublyLinkedList {\n    public Node head;\n    public Node tail;\n\n    public void setHead(Node node) {\n      // Write your code here.\n    }\n\n    public void setTail(Node node) {\n      // Write your code here.\n    }\n\n    public void insertBefore(Node node, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void insertAfter(Node node, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void insertAtPosition(int position, Node nodeToInsert) {\n      // Write your code here.\n    }\n\n    public void removeNodesWithValue(int value) {\n      // Write your code here.\n    }\n\n    public void remove(Node node) {\n      // Write your code here.\n    }\n\n    public boolean containsNodeWithValue(int value) {\n      // Write your code here.\n      return false;\n    }\n  }\n\n  // Do not edit the class below.\n  static class Node {\n    public int value;\n    public Node prev;\n    public Node next;\n\n    public Node(int value) {\n      this.value = value;\n    }\n  }\n}\n",
      "StartingTest": "import java.util.*;\n\nclass ProgramTest {\n  private void expectEmpty(Program.DoublyLinkedList linkedList) {\n    Utils.assertTrue(linkedList.head == null);\n    Utils.assertTrue(linkedList.tail == null);\n  }\n\n  private void expectHeadTail(\n      Program.DoublyLinkedList linkedList, Program.Node head, Program.Node tail) {\n    Utils.assertTrue(linkedList.head == head);\n    Utils.assertTrue(linkedList.tail == tail);\n  }\n\n  private void expectSingleNode(Program.DoublyLinkedList linkedList, Program.Node node) {\n    Utils.assertTrue(linkedList.head == node);\n    Utils.assertTrue(linkedList.tail == node);\n  }\n\n  private List<Integer> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.head;\n    while (node != null) {\n      values.add(node.value);\n      node = node.next;\n    }\n    return values;\n  }\n\n  private List<Integer> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.tail;\n    while (node != null) {\n      values.add(node.value);\n      node = node.prev;\n    }\n    return values;\n  }\n\n  private void removeNodes(Program.DoublyLinkedList linkedList, List<Program.Node> nodes) {\n    for (Program.Node node : nodes) {\n      linkedList.remove(node);\n    }\n  }\n\n  private boolean compare(List<Integer> array1, int[] array2) {\n    if (array1.size() != array2.length) {\n      return false;\n    }\n    for (int i = 0; i < array1.size(); i++) {\n      if (array1.get(i) != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node node = new Program.Node(1);\n\n    linkedList.setHead(node);\n    expectSingleNode(linkedList, node);\n    linkedList.remove(node);\n    expectEmpty(linkedList);\n    linkedList.setTail(node);\n    expectSingleNode(linkedList, node);\n    linkedList.removeNodesWithValue(1);\n    expectEmpty(linkedList);\n    linkedList.insertAtPosition(1, node);\n    expectSingleNode(linkedList, node);\n  }\n\n  @Test\n  public void TestCase2() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node first = new Program.Node(1);\n    Program.Node second = new Program.Node(2);\n    List<Program.Node> nodes = new ArrayList<Program.Node>();\n    nodes.add(first);\n    nodes.add(second);\n\n    linkedList.setHead(first);\n    linkedList.setTail(second);\n    expectHeadTail(linkedList, first, second);\n    removeNodes(linkedList, nodes);\n    expectEmpty(linkedList);\n    linkedList.setHead(first);\n    linkedList.insertAfter(first, second);\n    expectHeadTail(linkedList, first, second);\n    removeNodes(linkedList, nodes);\n    linkedList.setHead(first);\n    linkedList.insertBefore(first, second);\n    expectHeadTail(linkedList, second, first);\n    removeNodes(linkedList, nodes);\n    linkedList.insertAtPosition(1, first);\n    linkedList.insertAtPosition(2, second);\n    expectHeadTail(linkedList, first, second);\n    removeNodes(linkedList, nodes);\n    linkedList.insertAtPosition(2, first);\n    linkedList.insertAtPosition(1, second);\n    expectHeadTail(linkedList, second, first);\n  }\n\n  @Test\n  public void TestCase3() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node first = new Program.Node(1);\n    Program.Node second = new Program.Node(2);\n    Program.Node third = new Program.Node(3);\n    Program.Node fourth = new Program.Node(4);\n\n    linkedList.setHead(first);\n    Utils.assertTrue(linkedList.containsNodeWithValue(1) == true);\n    linkedList.insertAfter(first, second);\n    Utils.assertTrue(linkedList.containsNodeWithValue(2) == true);\n    linkedList.insertAfter(second, third);\n    Utils.assertTrue(linkedList.containsNodeWithValue(3) == true);\n    linkedList.insertAfter(third, fourth);\n    Utils.assertTrue(linkedList.containsNodeWithValue(4) == true);\n    linkedList.removeNodesWithValue(3);\n    Utils.assertTrue(linkedList.containsNodeWithValue(3) == false);\n    linkedList.remove(first);\n    Utils.assertTrue(linkedList.containsNodeWithValue(1) == false);\n    linkedList.removeNodesWithValue(4);\n    Utils.assertTrue(linkedList.containsNodeWithValue(4) == false);\n    linkedList.remove(second);\n    Utils.assertTrue(linkedList.containsNodeWithValue(2) == false);\n  }\n\n  @Test\n  public void TestCase4() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node first = new Program.Node(1);\n    Program.Node second = new Program.Node(2);\n    Program.Node third = new Program.Node(3);\n    Program.Node fourth = new Program.Node(3);\n    Program.Node fifth = new Program.Node(3);\n    Program.Node sixth = new Program.Node(6);\n    Program.Node seventh = new Program.Node(7);\n\n    linkedList.setHead(first);\n    linkedList.insertAfter(first, second);\n    linkedList.insertAfter(second, third);\n    linkedList.insertAfter(third, fourth);\n    linkedList.insertAfter(fourth, fifth);\n    linkedList.insertAfter(fifth, sixth);\n    linkedList.insertAfter(sixth, seventh);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {1, 2, 3, 3, 3, 6, 7}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {7, 6, 3, 3, 3, 2, 1}));\n    expectHeadTail(linkedList, first, seventh);\n    linkedList.remove(second);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {1, 3, 3, 3, 6, 7}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {7, 6, 3, 3, 3, 1}));\n    expectHeadTail(linkedList, first, seventh);\n    linkedList.removeNodesWithValue(1);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {3, 3, 3, 6, 7}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {7, 6, 3, 3, 3}));\n    expectHeadTail(linkedList, third, seventh);\n    linkedList.removeNodesWithValue(3);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {6, 7}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {7, 6}));\n    expectHeadTail(linkedList, sixth, seventh);\n    linkedList.removeNodesWithValue(7);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6}));\n    expectHeadTail(linkedList, sixth, sixth);\n  }\n\n  @Test\n  public void TestCase5() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node first = new Program.Node(1);\n    Program.Node second = new Program.Node(2);\n    Program.Node third = new Program.Node(3);\n    Program.Node fourth = new Program.Node(4);\n    Program.Node fifth = new Program.Node(5);\n    Program.Node sixth = new Program.Node(6);\n    Program.Node seventh = new Program.Node(7);\n\n    linkedList.setHead(first);\n    linkedList.insertAfter(first, second);\n    linkedList.insertAfter(second, third);\n    linkedList.insertAfter(third, fourth);\n    linkedList.insertAfter(fourth, fifth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {1, 2, 3, 4, 5}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {5, 4, 3, 2, 1}));\n    expectHeadTail(linkedList, first, fifth);\n    linkedList.insertAfter(third, fifth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {1, 2, 3, 5, 4}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {4, 5, 3, 2, 1}));\n    expectHeadTail(linkedList, first, fourth);\n    linkedList.insertAfter(third, first);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {2, 3, 1, 5, 4}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {4, 5, 1, 3, 2}));\n    expectHeadTail(linkedList, second, fourth);\n    linkedList.insertAfter(fifth, second);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {3, 1, 5, 2, 4}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {4, 2, 5, 1, 3}));\n    expectHeadTail(linkedList, third, fourth);\n    linkedList.insertAfter(second, first);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {3, 5, 2, 1, 4}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {4, 1, 2, 5, 3}));\n    expectHeadTail(linkedList, third, fourth);\n    linkedList.insertAfter(fourth, sixth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {3, 5, 2, 1, 4, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 4, 1, 2, 5, 3}));\n    expectHeadTail(linkedList, third, sixth);\n    linkedList.insertAfter(second, seventh);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {3, 5, 2, 7, 1, 4, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 4, 1, 7, 2, 5, 3}));\n    expectHeadTail(linkedList, third, sixth);\n  }\n\n  @Test\n  public void TestCase6() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node first = new Program.Node(1);\n    Program.Node second = new Program.Node(2);\n    Program.Node third = new Program.Node(3);\n    Program.Node fourth = new Program.Node(4);\n    Program.Node fifth = new Program.Node(5);\n    Program.Node sixth = new Program.Node(6);\n    Program.Node seventh = new Program.Node(7);\n\n    linkedList.setHead(first);\n    linkedList.insertBefore(first, second);\n    linkedList.insertBefore(second, third);\n    linkedList.insertBefore(third, fourth);\n    linkedList.insertBefore(fourth, fifth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {5, 4, 3, 2, 1}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {1, 2, 3, 4, 5}));\n    expectHeadTail(linkedList, fifth, first);\n    linkedList.insertBefore(third, first);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {5, 4, 1, 3, 2}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {2, 3, 1, 4, 5}));\n    expectHeadTail(linkedList, fifth, second);\n    linkedList.insertBefore(fifth, second);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {2, 5, 4, 1, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 1, 4, 5, 2}));\n    expectHeadTail(linkedList, second, third);\n    linkedList.insertBefore(fifth, fourth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {2, 4, 5, 1, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 1, 5, 4, 2}));\n    expectHeadTail(linkedList, second, third);\n    linkedList.insertBefore(second, sixth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {6, 2, 4, 5, 1, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 1, 5, 4, 2, 6}));\n    expectHeadTail(linkedList, sixth, third);\n    linkedList.insertBefore(first, seventh);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {6, 2, 4, 5, 7, 1, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 1, 7, 5, 4, 2, 6}));\n    expectHeadTail(linkedList, sixth, third);\n  }\n\n  @Test\n  public void TestCase7() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node first = new Program.Node(1);\n    Program.Node second = new Program.Node(2);\n    Program.Node third = new Program.Node(3);\n    Program.Node fourth = new Program.Node(4);\n    Program.Node fifth = new Program.Node(5);\n    Program.Node sixth = new Program.Node(6);\n    Program.Node seventh = new Program.Node(7);\n\n    linkedList.setHead(first);\n    linkedList.insertAtPosition(1, second);\n    linkedList.insertAtPosition(1, third);\n    linkedList.insertAtPosition(1, fourth);\n    linkedList.insertAtPosition(1, fifth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {5, 4, 3, 2, 1}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {1, 2, 3, 4, 5}));\n    expectHeadTail(linkedList, fifth, first);\n    linkedList.insertAtPosition(2, first);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {5, 1, 4, 3, 2}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {2, 3, 4, 1, 5}));\n    expectHeadTail(linkedList, fifth, second);\n    linkedList.insertAtPosition(1, second);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {2, 5, 1, 4, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 4, 1, 5, 2}));\n    expectHeadTail(linkedList, second, third);\n    linkedList.insertAtPosition(2, fourth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {2, 4, 5, 1, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 1, 5, 4, 2}));\n    expectHeadTail(linkedList, second, third);\n    linkedList.insertAtPosition(1, sixth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {6, 2, 4, 5, 1, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 1, 5, 4, 2, 6}));\n    expectHeadTail(linkedList, sixth, third);\n    linkedList.insertAtPosition(5, seventh);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {6, 2, 4, 5, 7, 1, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 1, 7, 5, 4, 2, 6}));\n    expectHeadTail(linkedList, sixth, third);\n    linkedList.insertAtPosition(8, fourth);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {6, 2, 5, 7, 1, 3, 4}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {4, 3, 1, 7, 5, 2, 6}));\n    expectHeadTail(linkedList, sixth, fourth);\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  private List<Integer> getNodeValuesHeadToTail(Program.DoublyLinkedList linkedList) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.head;\n    while (node != null) {\n      values.add(node.value);\n      node = node.next;\n    }\n    return values;\n  }\n\n  private List<Integer> getNodeValuesTailToHead(Program.DoublyLinkedList linkedList) {\n    List<Integer> values = new ArrayList<Integer>();\n    Program.Node node = linkedList.tail;\n    while (node != null) {\n      values.add(node.value);\n      node = node.prev;\n    }\n    return values;\n  }\n\n  private void bindNodes(Program.Node nodeOne, Program.Node nodeTwo) {\n    nodeOne.next = nodeTwo;\n    nodeTwo.prev = nodeOne;\n  }\n\n  private boolean compare(List<Integer> array1, int[] array2) {\n    if (array1.size() != array2.length) {\n      return false;\n    }\n    for (int i = 0; i < array1.size(); i++) {\n      if (array1.get(i) != array2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Test\n  public void TestCase1() {\n    Program.DoublyLinkedList linkedList = new Program.DoublyLinkedList();\n    Program.Node one = new Program.Node(1);\n    Program.Node two = new Program.Node(2);\n    Program.Node three = new Program.Node(3);\n    Program.Node three2 = new Program.Node(3);\n    Program.Node three3 = new Program.Node(3);\n    Program.Node four = new Program.Node(4);\n    Program.Node five = new Program.Node(5);\n    Program.Node six = new Program.Node(6);\n    bindNodes(one, two);\n    bindNodes(two, three);\n    bindNodes(three, four);\n    bindNodes(four, five);\n    linkedList.head = one;\n    linkedList.tail = five;\n\n    linkedList.setHead(four);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {5, 3, 2, 1, 4}));\n    \n    linkedList.setTail(six);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 3, 5, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 3, 2, 1, 4}));\n    \n    linkedList.insertBefore(six, three);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 3, 5, 2, 1, 4}));\n    \n    linkedList.insertAfter(six, three2);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 3, 6, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4}));\n    \n    linkedList.insertAtPosition(1, three3);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {3, 4, 1, 2, 5, 3, 6, 3}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {3, 6, 3, 5, 2, 1, 4, 3}));\n    \n    linkedList.removeNodesWithValue(3);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 2, 5, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 2, 1, 4}));\n    \n    linkedList.remove(two);\n    Utils.assertTrue(compare(getNodeValuesHeadToTail(linkedList), new int[] {4, 1, 5, 6}));\n    Utils.assertTrue(compare(getNodeValuesTailToHead(linkedList), new int[] {6, 5, 1, 4}));\n\n    Utils.assertTrue(linkedList.containsNodeWithValue(5));\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Program {\n  static class DoublyLinkedList {\n    public Node head;\n    public Node tail;\n\n    // O(1) time | O(1) space\n    public void setHead(Node node) {\n      if (head == null) {\n        head = node;\n        tail = node;\n        return;\n      }\n      insertBefore(head, node);\n    }\n\n    // O(1) time | O(1) space\n    public void setTail(Node node) {\n      if (tail == null) {\n        setHead(node);\n        return;\n      }\n      insertAfter(tail, node);\n    }\n\n    // O(1) time | O(1) space\n    public void insertBefore(Node node, Node nodeToInsert) {\n      if (nodeToInsert == head && nodeToInsert == tail) return;\n      remove(nodeToInsert);\n      nodeToInsert.prev = node.prev;\n      nodeToInsert.next = node;\n      if (node.prev == null) {\n        head = nodeToInsert;\n      } else {\n        node.prev.next = nodeToInsert;\n      }\n      node.prev = nodeToInsert;\n    }\n\n    // O(1) time | O(1) space\n    public void insertAfter(Node node, Node nodeToInsert) {\n      if (nodeToInsert == head && nodeToInsert == tail) return;\n      remove(nodeToInsert);\n      nodeToInsert.prev = node;\n      nodeToInsert.next = node.next;\n      if (node.next == null) {\n        tail = nodeToInsert;\n      } else {\n        node.next.prev = nodeToInsert;\n      }\n      node.next = nodeToInsert;\n    }\n\n    // O(p) time | O(1) space\n    public void insertAtPosition(int position, Node nodeToInsert) {\n      if (position == 1) {\n        setHead(nodeToInsert);\n        return;\n      }\n      Node node = head;\n      int currentPosition = 1;\n      while (node != null && currentPosition++ != position) node = node.next;\n      if (node != null) {\n        insertBefore(node, nodeToInsert);\n      } else {\n        setTail(nodeToInsert);\n      }\n    }\n\n    // O(n) time | O(1) space\n    public void removeNodesWithValue(int value) {\n      Node node = head;\n      while (node != null) {\n        Node nodeToRemove = node;\n        node = node.next;\n        if (nodeToRemove.value == value) remove(nodeToRemove);\n      }\n    }\n\n    // O(1) time | O(1) space\n    public void remove(Node node) {\n      if (node == head) head = head.next;\n      if (node == tail) tail = tail.prev;\n      removeNodeBindings(node);\n    }\n\n    // O(n) time | O(1) space\n    public boolean containsNodeWithValue(int value) {\n      Node node = head;\n      while (node != null && node.value != value) node = node.next;\n      return node != null;\n    }\n\n    public void removeNodeBindings(Node node) {\n      if (node.prev != null) node.prev.next = node.next;\n      if (node.next != null) node.next.prev = node.prev;\n      node.prev = null;\n      node.next = null;\n    }\n  }\n\n  static class Node {\n    public int value;\n    public Node prev;\n    public Node next;\n\n    public Node(int value) {\n      this.value = value;\n    }\n  }\n}\n"
      ]
    },
    "javascript": {
      "Language": "javascript",
      "StartingCode": "// This is an input class. Do not edit.\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n// Feel free to add new properties and methods to the class.\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHead(node) {\n    // Write your code here.\n  }\n\n  setTail(node) {\n    // Write your code here.\n  }\n\n  insertBefore(node, nodeToInsert) {\n    // Write your code here.\n  }\n\n  insertAfter(node, nodeToInsert) {\n    // Write your code here.\n  }\n\n  insertAtPosition(position, nodeToInsert) {\n    // Write your code here.\n  }\n\n  removeNodesWithValue(value) {\n    // Write your code here.\n  }\n\n  remove(node) {\n    // Write your code here.\n  }\n\n  containsNodeWithValue(value) {\n    // Write your code here.\n  }\n}\n\n// Do not edit the line below.\nexports.Node = Node;\nexports.DoublyLinkedList = DoublyLinkedList;\n",
      "StartingTest": "const program = require('./program');\nconst chai = require('chai');\n\nclass StartNode {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst nodeClass = program.Node || StartNode;\n\nclass Node extends nodeClass {\n  constructor(value) {\n    super(value);\n  }\n}\n\nfunction expectEmpty(linkedList) {\n  chai.expect(linkedList.head).to.deep.equal(null);\n  chai.expect(linkedList.tail).to.deep.equal(null);\n}\n\nfunction expectHeadTail(linkedList, head, tail) {\n  chai.expect(linkedList.head).to.deep.equal(head);\n  chai.expect(linkedList.tail).to.deep.equal(tail);\n}\n\nfunction expectSingleNode(linkedList, node) {\n  chai.expect(linkedList.head).to.deep.equal(node);\n  chai.expect(linkedList.tail).to.deep.equal(node);\n}\n\nfunction getNodeValuesHeadToTail(linkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction removeNodes(linkedList, nodes) {\n  for (const node of nodes) {\n    linkedList.remove(node);\n  }\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const node = new Node(1);\n\n  linkedList.setHead(node);\n  expectSingleNode(linkedList, node);\n  linkedList.remove(node);\n  expectEmpty(linkedList);\n  linkedList.setTail(node);\n  expectSingleNode(linkedList, node);\n  linkedList.removeNodesWithValue(1);\n  expectEmpty(linkedList);\n  linkedList.insertAtPosition(1, node);\n  expectSingleNode(linkedList, node);\n});\n\nit('Test Case #2', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const first = new Node(1);\n  const second = new Node(2);\n  const nodes = [first, second];\n\n  linkedList.setHead(first);\n  linkedList.setTail(second);\n  expectHeadTail(linkedList, first, second);\n  removeNodes(linkedList, nodes);\n  expectEmpty(linkedList);\n  linkedList.setHead(first);\n  linkedList.insertAfter(first, second);\n  expectHeadTail(linkedList, first, second);\n  removeNodes(linkedList, nodes);\n  linkedList.setHead(first);\n  linkedList.insertBefore(first, second);\n  expectHeadTail(linkedList, second, first);\n  removeNodes(linkedList, nodes);\n  linkedList.insertAtPosition(1, first);\n  linkedList.insertAtPosition(2, second);\n  expectHeadTail(linkedList, first, second);\n  removeNodes(linkedList, nodes);\n  linkedList.insertAtPosition(2, first);\n  linkedList.insertAtPosition(1, second);\n  expectHeadTail(linkedList, second, first);\n});\n\nit('Test Case #3', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const first = new Node(1);\n  const second = new Node(2);\n  const third = new Node(3);\n  const fourth = new Node(4);\n\n  linkedList.setHead(first);\n  chai.expect(linkedList.containsNodeWithValue(1)).to.deep.equal(true);\n  linkedList.insertAfter(first, second);\n  chai.expect(linkedList.containsNodeWithValue(2)).to.deep.equal(true);\n  linkedList.insertAfter(second, third);\n  chai.expect(linkedList.containsNodeWithValue(3)).to.deep.equal(true);\n  linkedList.insertAfter(third, fourth);\n  chai.expect(linkedList.containsNodeWithValue(4)).to.deep.equal(true);\n  linkedList.removeNodesWithValue(3);\n  chai.expect(linkedList.containsNodeWithValue(3)).to.deep.equal(false);\n  linkedList.remove(first);\n  chai.expect(linkedList.containsNodeWithValue(1)).to.deep.equal(false);\n  linkedList.removeNodesWithValue(4);\n  chai.expect(linkedList.containsNodeWithValue(4)).to.deep.equal(false);\n  linkedList.remove(second);\n  chai.expect(linkedList.containsNodeWithValue(2)).to.deep.equal(false);\n});\n\nit('Test Case #4', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const first = new Node(1);\n  const second = new Node(2);\n  const third = new Node(3);\n  const fourth = new Node(3);\n  const fifth = new Node(3);\n  const sixth = new Node(6);\n  const seventh = new Node(7);\n\n  linkedList.setHead(first);\n  linkedList.insertAfter(first, second);\n  linkedList.insertAfter(second, third);\n  linkedList.insertAfter(third, fourth);\n  linkedList.insertAfter(fourth, fifth);\n  linkedList.insertAfter(fifth, sixth);\n  linkedList.insertAfter(sixth, seventh);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([1, 2, 3, 3, 3, 6, 7]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([7, 6, 3, 3, 3, 2, 1]);\n  expectHeadTail(linkedList, first, seventh);\n  linkedList.remove(second);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([1, 3, 3, 3, 6, 7]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([7, 6, 3, 3, 3, 1]);\n  expectHeadTail(linkedList, first, seventh);\n  linkedList.removeNodesWithValue(1);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 3, 3, 6, 7]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([7, 6, 3, 3, 3]);\n  expectHeadTail(linkedList, third, seventh);\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([6, 7]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([7, 6]);\n  expectHeadTail(linkedList, sixth, seventh);\n  linkedList.removeNodesWithValue(7);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6]);\n  expectHeadTail(linkedList, sixth, sixth);\n});\n\nit('Test Case #5', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const first = new Node(1);\n  const second = new Node(2);\n  const third = new Node(3);\n  const fourth = new Node(4);\n  const fifth = new Node(5);\n  const sixth = new Node(6);\n  const seventh = new Node(7);\n\n  linkedList.setHead(first);\n  linkedList.insertAfter(first, second);\n  linkedList.insertAfter(second, third);\n  linkedList.insertAfter(third, fourth);\n  linkedList.insertAfter(fourth, fifth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([1, 2, 3, 4, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 4, 3, 2, 1]);\n  expectHeadTail(linkedList, first, fifth);\n  linkedList.insertAfter(third, fifth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([1, 2, 3, 5, 4]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([4, 5, 3, 2, 1]);\n  expectHeadTail(linkedList, first, fourth);\n  linkedList.insertAfter(third, first);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([2, 3, 1, 5, 4]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([4, 5, 1, 3, 2]);\n  expectHeadTail(linkedList, second, fourth);\n  linkedList.insertAfter(fifth, second);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 1, 5, 2, 4]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([4, 2, 5, 1, 3]);\n  expectHeadTail(linkedList, third, fourth);\n  linkedList.insertAfter(second, first);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 5, 2, 1, 4]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([4, 1, 2, 5, 3]);\n  expectHeadTail(linkedList, third, fourth);\n  linkedList.insertAfter(fourth, sixth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 5, 2, 1, 4, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 4, 1, 2, 5, 3]);\n  expectHeadTail(linkedList, third, sixth);\n  linkedList.insertAfter(second, seventh);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 5, 2, 7, 1, 4, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 4, 1, 7, 2, 5, 3]);\n  expectHeadTail(linkedList, third, sixth);\n});\n\nit('Test Case #6', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const first = new Node(1);\n  const second = new Node(2);\n  const third = new Node(3);\n  const fourth = new Node(4);\n  const fifth = new Node(5);\n  const sixth = new Node(6);\n  const seventh = new Node(7);\n\n  linkedList.setHead(first);\n  linkedList.insertBefore(first, second);\n  linkedList.insertBefore(second, third);\n  linkedList.insertBefore(third, fourth);\n  linkedList.insertBefore(fourth, fifth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([5, 4, 3, 2, 1]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([1, 2, 3, 4, 5]);\n  expectHeadTail(linkedList, fifth, first);\n  linkedList.insertBefore(third, first);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([5, 4, 1, 3, 2]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([2, 3, 1, 4, 5]);\n  expectHeadTail(linkedList, fifth, second);\n  linkedList.insertBefore(fifth, second);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([2, 5, 4, 1, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 1, 4, 5, 2]);\n  expectHeadTail(linkedList, second, third);\n  linkedList.insertBefore(fifth, fourth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([2, 4, 5, 1, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 1, 5, 4, 2]);\n  expectHeadTail(linkedList, second, third);\n  linkedList.insertBefore(second, sixth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([6, 2, 4, 5, 1, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 1, 5, 4, 2, 6]);\n  expectHeadTail(linkedList, sixth, third);\n  linkedList.insertBefore(first, seventh);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([6, 2, 4, 5, 7, 1, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 1, 7, 5, 4, 2, 6]);\n  expectHeadTail(linkedList, sixth, third);\n});\n\nit('Test Case #7', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const first = new Node(1);\n  const second = new Node(2);\n  const third = new Node(3);\n  const fourth = new Node(4);\n  const fifth = new Node(5);\n  const sixth = new Node(6);\n  const seventh = new Node(7);\n\n  linkedList.setHead(first);\n  linkedList.insertAtPosition(1, second);\n  linkedList.insertAtPosition(1, third);\n  linkedList.insertAtPosition(1, fourth);\n  linkedList.insertAtPosition(1, fifth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([5, 4, 3, 2, 1]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([1, 2, 3, 4, 5]);\n  expectHeadTail(linkedList, fifth, first);\n  linkedList.insertAtPosition(2, first);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([5, 1, 4, 3, 2]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([2, 3, 4, 1, 5]);\n  expectHeadTail(linkedList, fifth, second);\n  linkedList.insertAtPosition(1, second);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([2, 5, 1, 4, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 4, 1, 5, 2]);\n  expectHeadTail(linkedList, second, third);\n  linkedList.insertAtPosition(2, fourth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([2, 4, 5, 1, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 1, 5, 4, 2]);\n  expectHeadTail(linkedList, second, third);\n  linkedList.insertAtPosition(1, sixth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([6, 2, 4, 5, 1, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 1, 5, 4, 2, 6]);\n  expectHeadTail(linkedList, sixth, third);\n  linkedList.insertAtPosition(5, seventh);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([6, 2, 4, 5, 7, 1, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 1, 7, 5, 4, 2, 6]);\n  expectHeadTail(linkedList, sixth, third);\n  linkedList.insertAtPosition(8, fourth);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([6, 2, 5, 7, 1, 3, 4]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([4, 3, 1, 7, 5, 2, 6]);\n  expectHeadTail(linkedList, sixth, fourth);\n});\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nclass TestNode {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne, nodeTwo) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nclass DoublyLinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // O(1) time | O(1) space\n  setHead(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      return;\n    }\n    this.insertBefore(this.head, node);\n  }\n\n  // O(1) time | O(1) space\n  setTail(node) {\n    if (this.tail === null) {\n      this.setHead(node);\n      return;\n    }\n    this.insertAfter(this.tail, node);\n  }\n\n  // O(1) time | O(1) space\n  insertBefore(node, nodeToInsert) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node.prev;\n    nodeToInsert.next = node;\n    if (node.prev === null) {\n      this.head = nodeToInsert;\n    } else {\n      node.prev.next = nodeToInsert;\n    }\n    node.prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  insertAfter(node, nodeToInsert) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node;\n    nodeToInsert.next = node.next;\n    if (node.next === null) {\n      this.tail = nodeToInsert;\n    } else {\n      node.next.prev = nodeToInsert;\n    }\n    node.next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  insertAtPosition(position, nodeToInsert) {\n    if (position === 1) {\n      this.setHead(nodeToInsert);\n      return;\n    }\n    let node = this.head;\n    let currentPosition = 1;\n    while (node !== null && currentPosition++ !== position) node = node.next;\n    if (node !== null) {\n      this.insertBefore(node, nodeToInsert);\n    } else {\n      this.setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  removeNodesWithValue(value) {\n    let node = this.head;\n    while (node !== null) {\n      const nodeToRemove = node;\n      node = node.next;\n      if (nodeToRemove.value === value) this.remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  remove(node) {\n    if (node === this.head) this.head = this.head.next;\n    if (node === this.tail) this.tail = this.tail.prev;\n    this.removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  containsNodeWithValue(value) {\n    let node = this.head;\n    while (node !== null && node.value !== value) node = node.next;\n    return node !== null;\n  }\n\n  removeNodeBindings(node) {\n    if (node.prev !== null) node.prev.next = node.next;\n    if (node.next !== null) node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n  }\n}\n\nexports.Node = Node;\nexports.DoublyLinkedList = DoublyLinkedList;\n"
      ]
    },
    "python": {
      "Language": "python",
      "StartingCode": "# This is an input class. Do not edit.\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\n# Feel free to add new properties and methods to the class.\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def setHead(self, node):\n        # Write your code here.\n        pass\n\n    def setTail(self, node):\n        # Write your code here.\n        pass\n\n    def insertBefore(self, node, nodeToInsert):\n        # Write your code here.\n        pass\n\n    def insertAfter(self, node, nodeToInsert):\n        # Write your code here.\n        pass\n\n    def insertAtPosition(self, position, nodeToInsert):\n        # Write your code here.\n        pass\n\n    def removeNodesWithValue(self, value):\n        # Write your code here.\n        pass\n\n    def remove(self, node):\n        # Write your code here.\n        pass\n\n    def containsNodeWithValue(self, value):\n        # Write your code here.\n        pass\n",
      "StartingTest": "import program\nimport unittest\n\n\nclass StartNode:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nnodeClass = StartNode\nif hasattr(program, \"Node\"):\n    nodeClass = program.Node\n\n\nclass Node(nodeClass):\n    pass\n\n\ndef expectEmpty(self, linkedList):\n    self.assertEqual(linkedList.head, None)\n    self.assertEqual(linkedList.tail, None)\n\n\ndef expectHeadTail(self, linkedList, head, tail):\n    self.assertEqual(linkedList.head, head)\n    self.assertEqual(linkedList.tail, tail)\n\n\ndef expectSingleNode(self, linkedList, node):\n    self.assertEqual(linkedList.head, node)\n    self.assertEqual(linkedList.tail, node)\n\n\ndef getNodeValuesHeadToTail(linkedList):\n    values = []\n    node = linkedList.head\n    while node is not None:\n        values.append(node.value)\n        node = node.next\n    return values\n\n\ndef getNodeValuesTailToHead(linkedList):\n    values = []\n    node = linkedList.tail\n    while node is not None:\n        values.append(node.value)\n        node = node.prev\n    return values\n\n\ndef removeNodes(linkedList, nodes):\n    for node in nodes:\n        linkedList.remove(node)\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        linkedList = program.DoublyLinkedList()\n        node = Node(1)\n\n        linkedList.setHead(node)\n        expectSingleNode(self, linkedList, node)\n        linkedList.remove(node)\n        expectEmpty(self, linkedList)\n        linkedList.setTail(node)\n        expectSingleNode(self, linkedList, node)\n        linkedList.removeNodesWithValue(1)\n        expectEmpty(self, linkedList)\n        linkedList.insertAtPosition(1, node)\n        expectSingleNode(self, linkedList, node)\n\n    def test_case_2(self):\n        linkedList = program.DoublyLinkedList()\n        first = Node(1)\n        second = Node(2)\n        nodes = [first, second]\n\n        linkedList.setHead(first)\n        linkedList.setTail(second)\n        expectHeadTail(self, linkedList, first, second)\n        removeNodes(linkedList, nodes)\n        expectEmpty(self, linkedList)\n        linkedList.setHead(first)\n        linkedList.insertAfter(first, second)\n        expectHeadTail(self, linkedList, first, second)\n        removeNodes(linkedList, nodes)\n        linkedList.setHead(first)\n        linkedList.insertBefore(first, second)\n        expectHeadTail(self, linkedList, second, first)\n        removeNodes(linkedList, nodes)\n        linkedList.insertAtPosition(1, first)\n        linkedList.insertAtPosition(2, second)\n        expectHeadTail(self, linkedList, first, second)\n        removeNodes(linkedList, nodes)\n        linkedList.insertAtPosition(2, first)\n        linkedList.insertAtPosition(1, second)\n        expectHeadTail(self, linkedList, second, first)\n\n    def test_case_3(self):\n        linkedList = program.DoublyLinkedList()\n        first = Node(1)\n        second = Node(2)\n        third = Node(3)\n        fourth = Node(4)\n\n        linkedList.setHead(first)\n        self.assertEqual(linkedList.containsNodeWithValue(1), True)\n        linkedList.insertAfter(first, second)\n        self.assertEqual(linkedList.containsNodeWithValue(2), True)\n        linkedList.insertAfter(second, third)\n        self.assertEqual(linkedList.containsNodeWithValue(3), True)\n        linkedList.insertAfter(third, fourth)\n        self.assertEqual(linkedList.containsNodeWithValue(4), True)\n        linkedList.removeNodesWithValue(3)\n        self.assertEqual(linkedList.containsNodeWithValue(3), False)\n        linkedList.remove(first)\n        self.assertEqual(linkedList.containsNodeWithValue(1), False)\n        linkedList.removeNodesWithValue(4)\n        self.assertEqual(linkedList.containsNodeWithValue(4), False)\n        linkedList.remove(second)\n        self.assertEqual(linkedList.containsNodeWithValue(2), False)\n\n    def test_case_4(self):\n        linkedList = program.DoublyLinkedList()\n        first = Node(1)\n        second = Node(2)\n        third = Node(3)\n        fourth = Node(3)\n        fifth = Node(3)\n        sixth = Node(6)\n        seventh = Node(7)\n\n        linkedList.setHead(first)\n        linkedList.insertAfter(first, second)\n        linkedList.insertAfter(second, third)\n        linkedList.insertAfter(third, fourth)\n        linkedList.insertAfter(fourth, fifth)\n        linkedList.insertAfter(fifth, sixth)\n        linkedList.insertAfter(sixth, seventh)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [1, 2, 3, 3, 3, 6, 7])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [7, 6, 3, 3, 3, 2, 1])\n        expectHeadTail(self, linkedList, first, seventh)\n        linkedList.remove(second)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [1, 3, 3, 3, 6, 7])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [7, 6, 3, 3, 3, 1])\n        expectHeadTail(self, linkedList, first, seventh)\n        linkedList.removeNodesWithValue(1)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 3, 3, 6, 7])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [7, 6, 3, 3, 3])\n        expectHeadTail(self, linkedList, third, seventh)\n        linkedList.removeNodesWithValue(3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [6, 7])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [7, 6])\n        expectHeadTail(self, linkedList, sixth, seventh)\n        linkedList.removeNodesWithValue(7)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6])\n        expectHeadTail(self, linkedList, sixth, sixth)\n\n    def test_case_5(self):\n        linkedList = program.DoublyLinkedList()\n        first = Node(1)\n        second = Node(2)\n        third = Node(3)\n        fourth = Node(4)\n        fifth = Node(5)\n        sixth = Node(6)\n        seventh = Node(7)\n\n        linkedList.setHead(first)\n        linkedList.insertAfter(first, second)\n        linkedList.insertAfter(second, third)\n        linkedList.insertAfter(third, fourth)\n        linkedList.insertAfter(fourth, fifth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [1, 2, 3, 4, 5])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [5, 4, 3, 2, 1])\n        expectHeadTail(self, linkedList, first, fifth)\n        linkedList.insertAfter(third, fifth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [1, 2, 3, 5, 4])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [4, 5, 3, 2, 1])\n        expectHeadTail(self, linkedList, first, fourth)\n        linkedList.insertAfter(third, first)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [2, 3, 1, 5, 4])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [4, 5, 1, 3, 2])\n        expectHeadTail(self, linkedList, second, fourth)\n        linkedList.insertAfter(fifth, second)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 1, 5, 2, 4])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [4, 2, 5, 1, 3])\n        expectHeadTail(self, linkedList, third, fourth)\n        linkedList.insertAfter(second, first)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 5, 2, 1, 4])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [4, 1, 2, 5, 3])\n        expectHeadTail(self, linkedList, third, fourth)\n        linkedList.insertAfter(fourth, sixth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 5, 2, 1, 4, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 4, 1, 2, 5, 3])\n        expectHeadTail(self, linkedList, third, sixth)\n        linkedList.insertAfter(second, seventh)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 5, 2, 7, 1, 4, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 4, 1, 7, 2, 5, 3])\n        expectHeadTail(self, linkedList, third, sixth)\n\n    def test_case_6(self):\n        linkedList = program.DoublyLinkedList()\n        first = Node(1)\n        second = Node(2)\n        third = Node(3)\n        fourth = Node(4)\n        fifth = Node(5)\n        sixth = Node(6)\n        seventh = Node(7)\n\n        linkedList.setHead(first)\n        linkedList.insertBefore(first, second)\n        linkedList.insertBefore(second, third)\n        linkedList.insertBefore(third, fourth)\n        linkedList.insertBefore(fourth, fifth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [5, 4, 3, 2, 1])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [1, 2, 3, 4, 5])\n        expectHeadTail(self, linkedList, fifth, first)\n        linkedList.insertBefore(third, first)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [5, 4, 1, 3, 2])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [2, 3, 1, 4, 5])\n        expectHeadTail(self, linkedList, fifth, second)\n        linkedList.insertBefore(fifth, second)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [2, 5, 4, 1, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 1, 4, 5, 2])\n        expectHeadTail(self, linkedList, second, third)\n        linkedList.insertBefore(fifth, fourth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [2, 4, 5, 1, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 1, 5, 4, 2])\n        expectHeadTail(self, linkedList, second, third)\n        linkedList.insertBefore(second, sixth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [6, 2, 4, 5, 1, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 1, 5, 4, 2, 6])\n        expectHeadTail(self, linkedList, sixth, third)\n        linkedList.insertBefore(first, seventh)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [6, 2, 4, 5, 7, 1, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 1, 7, 5, 4, 2, 6])\n        expectHeadTail(self, linkedList, sixth, third)\n\n    def test_case_7(self):\n        linkedList = program.DoublyLinkedList()\n        first = Node(1)\n        second = Node(2)\n        third = Node(3)\n        fourth = Node(4)\n        fifth = Node(5)\n        sixth = Node(6)\n        seventh = Node(7)\n\n        linkedList.setHead(first)\n        linkedList.insertAtPosition(1, second)\n        linkedList.insertAtPosition(1, third)\n        linkedList.insertAtPosition(1, fourth)\n        linkedList.insertAtPosition(1, fifth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [5, 4, 3, 2, 1])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [1, 2, 3, 4, 5])\n        expectHeadTail(self, linkedList, fifth, first)\n        linkedList.insertAtPosition(2, first)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [5, 1, 4, 3, 2])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [2, 3, 4, 1, 5])\n        expectHeadTail(self, linkedList, fifth, second)\n        linkedList.insertAtPosition(1, second)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [2, 5, 1, 4, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 4, 1, 5, 2])\n        expectHeadTail(self, linkedList, second, third)\n        linkedList.insertAtPosition(2, fourth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [2, 4, 5, 1, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 1, 5, 4, 2])\n        expectHeadTail(self, linkedList, second, third)\n        linkedList.insertAtPosition(1, sixth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [6, 2, 4, 5, 1, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 1, 5, 4, 2, 6])\n        expectHeadTail(self, linkedList, sixth, third)\n        linkedList.insertAtPosition(5, seventh)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [6, 2, 4, 5, 7, 1, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 1, 7, 5, 4, 2, 6])\n        expectHeadTail(self, linkedList, sixth, third)\n        linkedList.insertAtPosition(8, fourth)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [6, 2, 5, 7, 1, 3, 4])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [4, 3, 1, 7, 5, 2, 6])\n        expectHeadTail(self, linkedList, sixth, fourth)\n",
      "SandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestNode:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nNode = TestNode\nif hasattr(program, \"Node\"):\n    Node = program.Node\n\n\ndef getNodeValuesHeadToTail(linkedList):\n    values = []\n    node = linkedList.head\n    while node is not None:\n        values.append(node.value)\n        node = node.next\n    return values\n\n\ndef getNodeValuesTailToHead(linkedList):\n    values = []\n    node = linkedList.tail\n    while node is not None:\n        values.append(node.value)\n        node = node.prev\n    return values\n\n\ndef bindNodes(nodeOne, nodeTwo):\n    nodeOne.next = nodeTwo\n    nodeTwo.prev = nodeOne\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        linkedList = program.DoublyLinkedList()\n        one = Node(1)\n        two = Node(2)\n        three = Node(3)\n        three2 = Node(3)\n        three3 = Node(3)\n        four = Node(4)\n        five = Node(5)\n        six = Node(6)\n        bindNodes(one, two)\n        bindNodes(two, three)\n        bindNodes(three, four)\n        bindNodes(four, five)\n        linkedList.head = one\n        linkedList.tail = five\n\n        linkedList.setHead(four)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [5, 3, 2, 1, 4])\n\n        linkedList.setTail(six)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 3, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 3, 2, 1, 4])\n\n        linkedList.insertBefore(six, three)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAfter(six, three2)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4])\n\n        linkedList.insertAtPosition(1, three3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [3, 4, 1, 2, 5, 3, 6, 3])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [3, 6, 3, 5, 2, 1, 4, 3])\n\n        linkedList.removeNodesWithValue(3)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 2, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 2, 1, 4])\n\n        linkedList.remove(two)\n        self.assertEqual(getNodeValuesHeadToTail(linkedList), [4, 1, 5, 6])\n        self.assertEqual(getNodeValuesTailToHead(linkedList), [6, 5, 1, 4])\n\n        self.assertEqual(linkedList.containsNodeWithValue(5), True)\n",
      "Solutions": [
        "# Copyright © 2020 Code Complete. All rights reserved.\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    # O(1) time | O(1) space\n    def setHead(self, node):\n        if self.head is None:\n            self.head = node\n            self.tail = node\n            return\n        self.insertBefore(self.head, node)\n\n    # O(1) time | O(1) space\n    def setTail(self, node):\n        if self.tail is None:\n            self.setHead(node)\n            return\n        self.insertAfter(self.tail, node)\n\n    # O(1) time | O(1) space\n    def insertBefore(self, node, nodeToInsert):\n        if nodeToInsert == self.head and nodeToInsert == self.tail:\n            return\n        self.remove(nodeToInsert)\n        nodeToInsert.prev = node.prev\n        nodeToInsert.next = node\n        if node.prev is None:\n            self.head = nodeToInsert\n        else:\n            node.prev.next = nodeToInsert\n        node.prev = nodeToInsert\n\n    # O(1) time | O(1) space\n    def insertAfter(self, node, nodeToInsert):\n        if nodeToInsert == self.head and nodeToInsert == self.tail:\n            return\n        self.remove(nodeToInsert)\n        nodeToInsert.prev = node\n        nodeToInsert.next = node.next\n        if node.next is None:\n            self.tail = nodeToInsert\n        else:\n            node.next.prev = nodeToInsert\n        node.next = nodeToInsert\n\n    # O(p) time | O(1) space\n    def insertAtPosition(self, position, nodeToInsert):\n        if position == 1:\n            self.setHead(nodeToInsert)\n            return\n        node = self.head\n        currentPosition = 1\n        while node is not None and currentPosition != position:\n            node = node.next\n            currentPosition += 1\n        if node is not None:\n            self.insertBefore(node, nodeToInsert)\n        else:\n            self.setTail(nodeToInsert)\n\n    # O(n) time | O(1) space\n    def removeNodesWithValue(self, value):\n        node = self.head\n        while node is not None:\n            nodeToRemove = node\n            node = node.next\n            if nodeToRemove.value == value:\n                self.remove(nodeToRemove)\n\n    # O(1) time | O(1) space\n    def remove(self, node):\n        if node == self.head:\n            self.head = self.head.next\n        if node == self.tail:\n            self.tail = self.tail.prev\n        self.removeNodeBindings(node)\n\n    # O(n) time | O(1) space\n    def containsNodeWithValue(self, value):\n        node = self.head\n        while node is not None and node.value != value:\n            node = node.next\n        return node is not None\n\n    def removeNodeBindings(self, node):\n        if node.prev is not None:\n            node.prev.next = node.next\n        if node.next is not None:\n            node.next.prev = node.prev\n        node.prev = None\n        node.next = None\n"
      ]
    },
    "swift": {
      "Language": "swift",
      "StartingCode": "class Program {\n  class Node {\n    var value: Int\n    var previous: Node?\n    var next: Node?\n\n    init(value: Int) {\n      self.value = value\n      previous = nil\n      next = nil\n    }\n  }\n\n  class DoublyLinkedList {\n    var head: Node?\n    var tail: Node?\n\n    init() {\n      head = nil\n      tail = nil\n    }\n\n    func containsNodeWithValue(value: Int) -> Bool {\n      // Write your code here.\n      return false\n    }\n\n    func remove(node: Node) {\n      // Write your code here.\n    }\n\n    func removeNodesWithValue(value: Int) {\n      // Write your code here.\n    }\n\n    func insertBefore(node: Node, nodeToInsert: Node) {\n      // Write your code here.\n    }\n\n    func insertAfter(node: Node, nodeToInsert: Node) {\n      // Write your code here.\n    }\n\n    func setHead(node: Node) {\n      // Write your code here.\n    }\n\n    func setTail(node: Node) {\n      // Write your code here.\n    }\n\n    func insertAtPosition(position: Int, nodeToInsert: Node) {\n      // Write your code here.\n    }\n  }\n}\n",
      "StartingTest": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n      let node = Program.Node(value: 1)\n      linkedList.setHead(node: node)\n      try expectSingleNode(linkedList: linkedList, node: node)\n      linkedList.remove(node: node)\n      try expectEmpty(linkedList: linkedList)\n      linkedList.setTail(node: node)\n      try expectSingleNode(linkedList: linkedList, node: node)\n      linkedList.removeNodesWithValue(value: 1)\n      try expectEmpty(linkedList: linkedList)\n      linkedList.insertAtPosition(position: 1, nodeToInsert: node)\n      try expectSingleNode(linkedList: linkedList, node: node)\n    }\n    runTest(\"Test Case 2\") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n      let firstNode = Program.Node(value: 1)\n      let secondNode = Program.Node(value: 2)\n\n      let nodes = [firstNode, secondNode]\n\n      linkedList.setHead(node: firstNode)\n      linkedList.setTail(node: secondNode)\n\n      try expectHeadTail(linkedList: linkedList, head: firstNode, tail: secondNode)\n      try removeNodes(linkedList: linkedList, nodes: nodes)\n      try expectEmpty(linkedList: linkedList)\n\n      linkedList.setHead(node: firstNode)\n      linkedList.insertAfter(node: firstNode, nodeToInsert: secondNode)\n\n      try expectHeadTail(linkedList: linkedList, head: firstNode, tail: secondNode)\n      try removeNodes(linkedList: linkedList, nodes: nodes)\n\n      linkedList.insertAtPosition(position: 1, nodeToInsert: firstNode)\n      linkedList.insertAtPosition(position: 2, nodeToInsert: secondNode)\n\n      try expectHeadTail(linkedList: linkedList, head: firstNode, tail: secondNode)\n      try removeNodes(linkedList: linkedList, nodes: nodes)\n\n      linkedList.insertAtPosition(position: 2, nodeToInsert: firstNode)\n      linkedList.insertAtPosition(position: 1, nodeToInsert: secondNode)\n\n      try expectHeadTail(linkedList: linkedList, head: secondNode, tail: firstNode)\n      try removeNodes(linkedList: linkedList, nodes: nodes)\n    }\n    runTest(\"Test Case 3\") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n      let firstNode = Program.Node(value: 1)\n      let secondNode = Program.Node(value: 2)\n      let thirdNode = Program.Node(value: 3)\n      let fourthNode = Program.Node(value: 4)\n\n      linkedList.setHead(node: firstNode)\n      try assertEqual(true, linkedList.containsNodeWithValue(value: 1))\n      linkedList.insertAfter(node: firstNode, nodeToInsert: secondNode)\n      try assertEqual(true, linkedList.containsNodeWithValue(value: 2))\n      linkedList.insertAfter(node: secondNode, nodeToInsert: thirdNode)\n      try assertEqual(true, linkedList.containsNodeWithValue(value: 3))\n      linkedList.insertAfter(node: thirdNode, nodeToInsert: fourthNode)\n      try assertEqual(true, linkedList.containsNodeWithValue(value: 4))\n      linkedList.removeNodesWithValue(value: 3)\n      try assertEqual(false, linkedList.containsNodeWithValue(value: 3))\n      linkedList.remove(node: firstNode)\n      try assertEqual(false, linkedList.containsNodeWithValue(value: 1))\n      linkedList.removeNodesWithValue(value: 4)\n      try assertEqual(false, linkedList.containsNodeWithValue(value: 4))\n      linkedList.remove(node: secondNode)\n      try assertEqual(false, linkedList.containsNodeWithValue(value: 2))\n    }\n    runTest(\"Test Case 4\") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n\n      let firstNode = Program.Node(value: 1)\n      let secondNode = Program.Node(value: 2)\n      let thirdNode = Program.Node(value: 3)\n      let fourthNode = Program.Node(value: 3)\n      let fifthNode = Program.Node(value: 3)\n      let sixthNode = Program.Node(value: 6)\n      let seventhNode = Program.Node(value: 7)\n\n      linkedList.setHead(node: firstNode)\n      linkedList.insertAfter(node: firstNode, nodeToInsert: secondNode)\n      linkedList.insertAfter(node: secondNode, nodeToInsert: thirdNode)\n      linkedList.insertAfter(node: thirdNode, nodeToInsert: fourthNode)\n      linkedList.insertAfter(node: fourthNode, nodeToInsert: fifthNode)\n      linkedList.insertAfter(node: fifthNode, nodeToInsert: sixthNode)\n      linkedList.insertAfter(node: sixthNode, nodeToInsert: seventhNode)\n\n      try assertEqual([1, 2, 3, 3, 3, 6, 7], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([7, 6, 3, 3, 3, 2, 1], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: firstNode, tail: seventhNode)\n\n      linkedList.remove(node: secondNode)\n\n      try assertEqual([1, 3, 3, 3, 6, 7], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([7, 6, 3, 3, 3, 1], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: firstNode, tail: seventhNode)\n\n      linkedList.removeNodesWithValue(value: 1)\n\n      try assertEqual([3, 3, 3, 6, 7], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([7, 6, 3, 3, 3], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: thirdNode, tail: seventhNode)\n\n      linkedList.removeNodesWithValue(value: 3)\n\n      try assertEqual([6, 7], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([7, 6], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: sixthNode, tail: seventhNode)\n\n      linkedList.removeNodesWithValue(value: 7)\n\n      try assertEqual([6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: sixthNode, tail: sixthNode)\n    }\n    runTest(\"Test Case 5\") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n\n      let firstNode = Program.Node(value: 1)\n      let secondNode = Program.Node(value: 2)\n      let thirdNode = Program.Node(value: 3)\n      let fourthNode = Program.Node(value: 4)\n      let fifthNode = Program.Node(value: 5)\n      let sixthNode = Program.Node(value: 6)\n      let seventhNode = Program.Node(value: 7)\n\n      linkedList.setHead(node: firstNode)\n      linkedList.insertAfter(node: firstNode, nodeToInsert: secondNode)\n      linkedList.insertAfter(node: secondNode, nodeToInsert: thirdNode)\n      linkedList.insertAfter(node: thirdNode, nodeToInsert: fourthNode)\n      linkedList.insertAfter(node: fourthNode, nodeToInsert: fifthNode)\n\n      try assertEqual([1, 2, 3, 4, 5], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([5, 4, 3, 2, 1], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: firstNode, tail: fifthNode)\n\n      linkedList.insertAfter(node: thirdNode, nodeToInsert: fifthNode)\n\n      try assertEqual([1, 2, 3, 5, 4], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([4, 5, 3, 2, 1], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: firstNode, tail: fourthNode)\n\n      linkedList.insertAfter(node: thirdNode, nodeToInsert: firstNode)\n\n      try assertEqual([2, 3, 1, 5, 4], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([4, 5, 1, 3, 2], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: secondNode, tail: fourthNode)\n\n      linkedList.insertAfter(node: fifthNode, nodeToInsert: secondNode)\n\n      try assertEqual([3, 1, 5, 2, 4], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([4, 2, 5, 1, 3], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: thirdNode, tail: fourthNode)\n\n      linkedList.insertAfter(node: secondNode, nodeToInsert: firstNode)\n\n      try assertEqual([3, 5, 2, 1, 4], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([4, 1, 2, 5, 3], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: thirdNode, tail: fourthNode)\n\n      linkedList.insertAfter(node: fourthNode, nodeToInsert: sixthNode)\n\n      try assertEqual([3, 5, 2, 1, 4, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 4, 1, 2, 5, 3], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: thirdNode, tail: sixthNode)\n\n      linkedList.insertAfter(node: secondNode, nodeToInsert: seventhNode)\n\n      try assertEqual([3, 5, 2, 7, 1, 4, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 4, 1, 7, 2, 5, 3], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: thirdNode, tail: sixthNode)\n    }\n    runTest(\"Test Case 6\") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n\n      let firstNode = Program.Node(value: 1)\n      let secondNode = Program.Node(value: 2)\n      let thirdNode = Program.Node(value: 3)\n      let fourthNode = Program.Node(value: 4)\n      let fifthNode = Program.Node(value: 5)\n      let sixthNode = Program.Node(value: 6)\n      let seventhNode = Program.Node(value: 7)\n\n      linkedList.setHead(node: firstNode)\n      linkedList.insertBefore(node: firstNode, nodeToInsert: secondNode)\n      linkedList.insertBefore(node: secondNode, nodeToInsert: thirdNode)\n      linkedList.insertBefore(node: thirdNode, nodeToInsert: fourthNode)\n      linkedList.insertBefore(node: fourthNode, nodeToInsert: fifthNode)\n\n      try assertEqual([5, 4, 3, 2, 1], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([1, 2, 3, 4, 5], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: fifthNode, tail: firstNode)\n\n      linkedList.insertBefore(node: thirdNode, nodeToInsert: firstNode)\n\n      try assertEqual([5, 4, 1, 3, 2], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([2, 3, 1, 4, 5], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: fifthNode, tail: secondNode)\n\n      linkedList.insertBefore(node: fifthNode, nodeToInsert: secondNode)\n\n      try assertEqual([2, 5, 4, 1, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 1, 4, 5, 2], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: secondNode, tail: thirdNode)\n\n      linkedList.insertBefore(node: fifthNode, nodeToInsert: fourthNode)\n\n      try assertEqual([2, 4, 5, 1, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 1, 5, 4, 2], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: secondNode, tail: thirdNode)\n\n      linkedList.insertBefore(node: secondNode, nodeToInsert: sixthNode)\n\n      try assertEqual([6, 2, 4, 5, 1, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 1, 5, 4, 2, 6], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: sixthNode, tail: thirdNode)\n\n      linkedList.insertBefore(node: firstNode, nodeToInsert: seventhNode)\n\n      try assertEqual([6, 2, 4, 5, 7, 1, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 1, 7, 5, 4, 2, 6], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: sixthNode, tail: thirdNode)\n    }\n    runTest(\"Test Case 7\") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n\n      let firstNode = Program.Node(value: 1)\n      let secondNode = Program.Node(value: 2)\n      let thirdNode = Program.Node(value: 3)\n      let fourthNode = Program.Node(value: 4)\n      let fifthNode = Program.Node(value: 5)\n      let sixthNode = Program.Node(value: 6)\n      let seventhNode = Program.Node(value: 7)\n\n      linkedList.setHead(node: firstNode)\n      linkedList.insertAtPosition(position: 1, nodeToInsert: secondNode)\n      linkedList.insertAtPosition(position: 1, nodeToInsert: thirdNode)\n      linkedList.insertAtPosition(position: 1, nodeToInsert: fourthNode)\n      linkedList.insertAtPosition(position: 1, nodeToInsert: fifthNode)\n\n      try assertEqual([5, 4, 3, 2, 1], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([1, 2, 3, 4, 5], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: fifthNode, tail: firstNode)\n\n      linkedList.insertAtPosition(position: 2, nodeToInsert: firstNode)\n\n      try assertEqual([5, 1, 4, 3, 2], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([2, 3, 4, 1, 5], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: fifthNode, tail: secondNode)\n\n      linkedList.insertAtPosition(position: 1, nodeToInsert: secondNode)\n\n      try assertEqual([2, 5, 1, 4, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 4, 1, 5, 2], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: secondNode, tail: thirdNode)\n\n      linkedList.insertAtPosition(position: 2, nodeToInsert: fourthNode)\n\n      try assertEqual([2, 4, 5, 1, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 1, 5, 4, 2], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: secondNode, tail: thirdNode)\n\n      linkedList.insertAtPosition(position: 1, nodeToInsert: sixthNode)\n\n      try assertEqual([6, 2, 4, 5, 1, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 1, 5, 4, 2, 6], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: sixthNode, tail: thirdNode)\n\n      linkedList.insertAtPosition(position: 5, nodeToInsert: seventhNode)\n\n      try assertEqual([6, 2, 4, 5, 7, 1, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 1, 7, 5, 4, 2, 6], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: sixthNode, tail: thirdNode)\n\n      linkedList.insertAtPosition(position: 8, nodeToInsert: fourthNode)\n\n      try assertEqual([6, 2, 5, 7, 1, 3, 4], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([4, 3, 1, 7, 5, 2, 6], getNodeValuesTailToHead(linkedList: linkedList))\n      try expectHeadTail(linkedList: linkedList, head: sixthNode, tail: fourthNode)\n    }\n  }\n\n  func expectEmpty(linkedList: Program.DoublyLinkedList) throws {\n    try assert(linkedList.head === nil)\n    try assert(linkedList.tail === nil)\n  }\n\n  // Asserts that the Linked List's head and tail are equal to given values\n  func expectHeadTail(linkedList: Program.DoublyLinkedList, head: Program.Node, tail: Program.Node) throws {\n    try assert(linkedList.head === head)\n    try assert(linkedList.tail === tail)\n  }\n\n  // Asserts that the Linked List contains only one node\n  func expectSingleNode(linkedList: Program.DoublyLinkedList, node: Program.Node) throws {\n    try assert(linkedList.head === node)\n    try assert(linkedList.tail === node)\n  }\n\n  // Returns node values from head to tail\n  func getNodeValuesHeadToTail(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.head\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.next\n    }\n\n    return values\n  }\n\n  func getNodeValuesTailToHead(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.tail\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.previous\n    }\n\n    return values\n  }\n\n  func removeNodes(linkedList: Program.DoublyLinkedList, nodes: [Program.Node]) throws {\n    for node in nodes {\n      linkedList.remove(node: node)\n    }\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      let linkedList = Program.DoublyLinkedList()\n      let one = Program.Node(value: 1)\n      let two = Program.Node(value: 2)\n      let three = Program.Node(value: 3)\n      let three2 = Program.Node(value: 3)\n      let three3 = Program.Node(value: 3)\n      let four = Program.Node(value: 4)\n      let five = Program.Node(value: 5)\n      let six = Program.Node(value: 6)\n      bindNodes(nodeOne: one, nodeTwo: two)\n      bindNodes(nodeOne: two, nodeTwo: three)\n      bindNodes(nodeOne: three, nodeTwo: four)\n      bindNodes(nodeOne: four, nodeTwo: five)\n      linkedList.head = one\n      linkedList.tail = five\n\n      linkedList.setHead(node: four)\n      try assertEqual([4, 1, 2, 3, 5], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.setTail(node: six)\n      try assertEqual([4, 1, 2, 3, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 3, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertBefore(node: six, nodeToInsert: three)\n      try assertEqual([4, 1, 2, 5, 3, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAfter(node: six, nodeToInsert: three2)\n      try assertEqual([4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.insertAtPosition(position: 1, nodeToInsert: three3)\n      try assertEqual([3, 4, 1, 2, 5, 3, 6, 3], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([3, 6, 3, 5, 2, 1, 4, 3], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.removeNodesWithValue(value: 3)\n      try assertEqual([4, 1, 2, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 2, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      linkedList.remove(node: two)\n      try assertEqual([4, 1, 5, 6], getNodeValuesHeadToTail(linkedList: linkedList))\n      try assertEqual([6, 5, 1, 4], getNodeValuesTailToHead(linkedList: linkedList))\n\n      try assertEqual(true, linkedList.containsNodeWithValue(value: 5))\n    }\n  }\n\n  func getNodeValuesHeadToTail(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.head\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.next\n    }\n\n    return values\n  }\n\n  func getNodeValuesTailToHead(linkedList: Program.DoublyLinkedList) throws -> [Int] {\n    var values = [Int]()\n\n    var node = linkedList.tail\n\n    while node != nil {\n      values.append(node!.value)\n      node = node?.previous\n    }\n\n    return values\n  }\n\n  func bindNodes(nodeOne: Program.Node, nodeTwo: Program.Node) {\n    nodeOne.next = nodeTwo\n    nodeTwo.previous = nodeOne\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Program {\n  class Node {\n    var value: Int\n    var previous: Node?\n    var next: Node?\n\n    init(value: Int) {\n      self.value = value\n      previous = nil\n      next = nil\n    }\n  }\n\n  class DoublyLinkedList {\n    var head: Node?\n    var tail: Node?\n\n    init() {\n      head = nil\n      tail = nil\n    }\n\n    // O(N) time | O(1) space\n    func containsNodeWithValue(value: Int) -> Bool {\n      var node = head\n      while node !== nil, node?.value != value {\n        node = node?.next\n      }\n\n      return node !== nil\n    }\n\n    // O(1) time | O(1) space\n    func remove(node: Node) {\n      if node === head {\n        head = head?.next\n      }\n\n      if node === tail {\n        tail = tail?.previous\n      }\n\n      removeNodeBindings(node: node)\n    }\n\n    // O(N) time | O(1) space\n    func removeNodesWithValue(value: Int) {\n      var node = head\n\n      while node !== nil {\n        let nodeToRemove = node\n        node = node?.next\n        if nodeToRemove?.value == value {\n          remove(node: nodeToRemove!)\n        }\n      }\n    }\n\n    // O(1) time | O(1) space\n    func insertBefore(node: Node, nodeToInsert: Node) {\n      if nodeToInsert === head, nodeToInsert === tail {\n        return\n      }\n\n      remove(node: nodeToInsert)\n      nodeToInsert.previous = node.previous\n      nodeToInsert.next = node\n\n      if node.previous == nil {\n        head = nodeToInsert\n      } else {\n        node.previous?.next = nodeToInsert\n      }\n\n      node.previous = nodeToInsert\n    }\n\n    // O(1) time | O(1) space\n    func insertAfter(node: Node, nodeToInsert: Node) {\n      if nodeToInsert === head, nodeToInsert === tail {\n        return\n      }\n\n      remove(node: nodeToInsert)\n      nodeToInsert.previous = node\n      nodeToInsert.next = node.next\n\n      if node.next == nil {\n        tail = nodeToInsert\n      } else {\n        node.next?.previous = nodeToInsert\n      }\n\n      node.next = nodeToInsert\n    }\n\n    // O(1) time | O(1) space\n    func setHead(node: Node) {\n      if head == nil {\n        head = node\n        tail = node\n        return\n      }\n\n      insertBefore(node: head!, nodeToInsert: node)\n    }\n\n    // O(1) time | O(1) space\n    func setTail(node: Node) {\n      if tail == nil {\n        setHead(node: node)\n        return\n      }\n\n      insertAfter(node: tail!, nodeToInsert: node)\n    }\n\n    // O(P) time | O(1) space\n    func insertAtPosition(position: Int, nodeToInsert: Node) {\n      if position == 1 {\n        setHead(node: nodeToInsert)\n        return\n      }\n\n      var node = head\n      var currentPosition = 1\n      while node !== nil, currentPosition != position {\n        node = node?.next\n        currentPosition = currentPosition + 1\n      }\n\n      if node !== nil {\n        insertBefore(node: node!, nodeToInsert: nodeToInsert)\n      } else {\n        setTail(node: nodeToInsert)\n      }\n    }\n\n    func removeNodeBindings(node: Node) {\n      if let previous = node.previous {\n        previous.next = node.next\n      }\n\n      if let next = node.next {\n        next.previous = node.previous\n      }\n\n      node.previous = nil\n      node.next = nil\n    }\n  }\n}\n"
      ]
    },
    "typescript": {
      "Language": "typescript",
      "StartingCode": "// This is an input class. Do not edit.\nclass Node {\n  value: number;\n  prev: Node | null;\n  next: Node | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n// Feel free to add new properties and methods to the class.\nexport class DoublyLinkedList {\n  head: Node | null;\n  tail: Node | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  setHead(node: Node) {\n    // Write your code here.\n  }\n\n  setTail(node: Node) {\n    // Write your code here.\n  }\n\n  insertBefore(node: Node, nodeToInsert: Node) {\n    // Write your code here.\n  }\n\n  insertAfter(node: Node, nodeToInsert: Node) {\n    // Write your code here.\n  }\n\n  insertAtPosition(position: number, nodeToInsert: Node) {\n    // Write your code here.\n  }\n\n  removeNodesWithValue(value: number) {\n    // Write your code here.\n  }\n\n  remove(node: Node) {\n    // Write your code here.\n  }\n\n  containsNodeWithValue(value: number) {\n    // Write your code here.\n    return false;\n  }\n}\n",
      "StartingTest": "",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nclass TestNode {\n  value: number;\n  prev: TestNode | null;\n  next: TestNode | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nconst Node = program.Node || TestNode;\n\nfunction getNodeValuesHeadToTail(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.head;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.next;\n  }\n  return values;\n}\n\nfunction getNodeValuesTailToHead(linkedList: program.DoublyLinkedList) {\n  const values = [];\n  let node = linkedList.tail;\n  while (node !== null) {\n    values.push(node.value);\n    node = node.prev;\n  }\n  return values;\n}\n\nfunction bindNodes(nodeOne: TestNode, nodeTwo: TestNode) {\n  nodeOne.next = nodeTwo;\n  nodeTwo.prev = nodeOne;\n}\n\nit('Test Case #1', function () {\n  const linkedList = new program.DoublyLinkedList();\n  const one = new Node(1);\n  const two = new Node(2);\n  const three = new Node(3);\n  const three2 = new Node(3);\n  const three3 = new Node(3);\n  const four = new Node(4);\n  const five = new Node(5);\n  const six = new Node(6);\n  bindNodes(one, two);\n  bindNodes(two, three);\n  bindNodes(three, four);\n  bindNodes(four, five);\n  linkedList.head = one;\n  linkedList.tail = five;\n\n  linkedList.setHead(four);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([5, 3, 2, 1, 4]);\n\n  linkedList.setTail(six);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 3, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 3, 2, 1, 4]);\n\n  linkedList.insertBefore(six, three);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAfter(six, three2);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4]);\n\n  linkedList.insertAtPosition(1, three3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([3, 4, 1, 2, 5, 3, 6, 3]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([3, 6, 3, 5, 2, 1, 4, 3]);\n\n  linkedList.removeNodesWithValue(3);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 2, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 2, 1, 4]);\n\n  linkedList.remove(two);\n  chai.expect(getNodeValuesHeadToTail(linkedList)).to.deep.equal([4, 1, 5, 6]);\n  chai.expect(getNodeValuesTailToHead(linkedList)).to.deep.equal([6, 5, 1, 4]);\n\n  chai.expect(linkedList.containsNodeWithValue(5)).to.deep.equal(true);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nexport class Node {\n  value: number;\n  prev: Node | null;\n  next: Node | null;\n\n  constructor(value: number) {\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nexport class DoublyLinkedList {\n  head: Node | null;\n  tail: Node | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // O(1) time | O(1) space\n  setHead(node: Node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      return;\n    }\n    this.insertBefore(this.head, node);\n  }\n\n  // O(1) time | O(1) space\n  setTail(node: Node) {\n    if (this.tail === null) {\n      this.setHead(node);\n      return;\n    }\n    this.insertAfter(this.tail, node);\n  }\n\n  // O(1) time | O(1) space\n  insertBefore(node: Node, nodeToInsert: Node) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node.prev;\n    nodeToInsert.next = node;\n    if (node.prev === null) {\n      this.head = nodeToInsert;\n    } else {\n      node.prev.next = nodeToInsert;\n    }\n    node.prev = nodeToInsert;\n  }\n\n  // O(1) time | O(1) space\n  insertAfter(node: Node, nodeToInsert: Node) {\n    if (nodeToInsert === this.head && nodeToInsert === this.tail) return;\n    this.remove(nodeToInsert);\n    nodeToInsert.prev = node;\n    nodeToInsert.next = node.next;\n    if (node.next === null) {\n      this.tail = nodeToInsert;\n    } else {\n      node.next.prev = nodeToInsert;\n    }\n    node.next = nodeToInsert;\n  }\n\n  // O(p) time | O(1) space\n  insertAtPosition(position: number, nodeToInsert: Node) {\n    if (position === 1) {\n      this.setHead(nodeToInsert);\n      return;\n    }\n    let node = this.head;\n    let currentPosition = 1;\n    while (node !== null && currentPosition++ !== position) node = node.next;\n    if (node !== null) {\n      this.insertBefore(node, nodeToInsert);\n    } else {\n      this.setTail(nodeToInsert);\n    }\n  }\n\n  // O(n) time | O(1) space\n  removeNodesWithValue(value: number) {\n    let node = this.head;\n    while (node !== null) {\n      const nodeToRemove = node;\n      node = node.next;\n      if (nodeToRemove.value === value) this.remove(nodeToRemove);\n    }\n  }\n\n  // O(1) time | O(1) space\n  remove(node: Node) {\n    if (node === this.head) this.head = this.head.next;\n    if (node === this.tail) this.tail = this.tail.prev;\n    this.removeNodeBindings(node);\n  }\n\n  // O(n) time | O(1) space\n  containsNodeWithValue(value: number) {\n    let node = this.head;\n    while (node !== null && node.value !== value) node = node.next;\n    return node !== null;\n  }\n\n  removeNodeBindings(node: Node) {\n    if (node.prev !== null) node.prev.next = node.next;\n    if (node.next !== null) node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n  }\n}\n"
      ]
    }
  },
  "JSONTestLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "JSONTests": [
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "5"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "3"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "6"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "6",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "6",
            "3-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1,
            "3-3"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            3
          ],
          "method": "removeNodesWithValue"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "remove"
        },
        {
          "arguments": [
            5
          ],
          "method": "containsNodeWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-2",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "3-3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        },
        {
          "id": "5",
          "next": null,
          "prev": null,
          "value": 5
        },
        {
          "id": "6",
          "next": null,
          "prev": null,
          "value": 6
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            1,
            "1"
          ],
          "method": "insertAtPosition"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setTail"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "setHead"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertBefore"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertBefore"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setTail"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertBefore"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "1"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertBefore"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "4",
            "5"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "5",
            "6"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "6",
            "7"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            7,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            1,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            2,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            3,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            4,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            5,
            "1"
          ],
          "method": "insertAtPosition"
        },
        {
          "arguments": [
            6,
            "1"
          ],
          "method": "insertAtPosition"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        },
        {
          "id": "5",
          "next": null,
          "prev": null,
          "value": 5
        },
        {
          "id": "6",
          "next": null,
          "prev": null,
          "value": 6
        },
        {
          "id": "7",
          "next": null,
          "prev": null,
          "value": 7
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            1
          ],
          "method": "removeNodesWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "4"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2"
          ],
          "method": "remove"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "1-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-2",
            "1-3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-3",
            "1-4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1
          ],
          "method": "removeNodesWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-2",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-3",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-4",
          "next": null,
          "prev": null,
          "value": 1
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "1-2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "1-3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "1-3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1
          ],
          "method": "removeNodesWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-2",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-3",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "1-4",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    },
    {
      "classMethodsToCall": [
        {
          "arguments": [
            "1"
          ],
          "method": "setHead"
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "method": "insertAfter"
        },
        {
          "arguments": [
            1
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            2
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            3
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            4
          ],
          "method": "containsNodeWithValue"
        },
        {
          "arguments": [
            5
          ],
          "method": "containsNodeWithValue"
        }
      ],
      "nodes": [
        {
          "id": "1",
          "next": null,
          "prev": null,
          "value": 1
        },
        {
          "id": "2",
          "next": null,
          "prev": null,
          "value": 2
        },
        {
          "id": "3",
          "next": null,
          "prev": null,
          "value": 3
        },
        {
          "id": "4",
          "next": null,
          "prev": null,
          "value": 4
        }
      ]
    }
  ],
  "JSONAnswers": [
    [
      [
        {
          "arguments": [
            "5"
          ],
          "linkedList": {
            "head": "5",
            "nodes": [
              {
                "id": "5",
                "next": null,
                "prev": null,
                "value": 5
              }
            ],
            "tail": "5"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "4"
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "5",
                "prev": null,
                "value": 4
              },
              {
                "id": "5",
                "next": null,
                "prev": "4",
                "value": 5
              }
            ],
            "tail": "5"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "3"
          ],
          "linkedList": {
            "head": "3",
            "nodes": [
              {
                "id": "3",
                "next": "4",
                "prev": null,
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": null,
                "prev": "4",
                "value": 5
              }
            ],
            "tail": "5"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "2"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "3",
                "prev": null,
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": null,
                "prev": "4",
                "value": 5
              }
            ],
            "tail": "5"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": null,
                "prev": "4",
                "value": 5
              }
            ],
            "tail": "5"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "4"
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "1",
                "prev": null,
                "value": 4
              },
              {
                "id": "1",
                "next": "2",
                "prev": "4",
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "5",
                "prev": "2",
                "value": 3
              },
              {
                "id": "5",
                "next": null,
                "prev": "3",
                "value": 5
              }
            ],
            "tail": "5"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "6"
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "1",
                "prev": null,
                "value": 4
              },
              {
                "id": "1",
                "next": "2",
                "prev": "4",
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "5",
                "prev": "2",
                "value": 3
              },
              {
                "id": "5",
                "next": "6",
                "prev": "3",
                "value": 5
              },
              {
                "id": "6",
                "next": null,
                "prev": "5",
                "value": 6
              }
            ],
            "tail": "6"
          },
          "method": "setTail",
          "output": null
        },
        {
          "arguments": [
            "6",
            "3"
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "1",
                "prev": null,
                "value": 4
              },
              {
                "id": "1",
                "next": "2",
                "prev": "4",
                "value": 1
              },
              {
                "id": "2",
                "next": "5",
                "prev": "1",
                "value": 2
              },
              {
                "id": "5",
                "next": "3",
                "prev": "2",
                "value": 5
              },
              {
                "id": "3",
                "next": "6",
                "prev": "5",
                "value": 3
              },
              {
                "id": "6",
                "next": null,
                "prev": "3",
                "value": 6
              }
            ],
            "tail": "6"
          },
          "method": "insertBefore",
          "output": null
        },
        {
          "arguments": [
            "6",
            "3-2"
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "1",
                "prev": null,
                "value": 4
              },
              {
                "id": "1",
                "next": "2",
                "prev": "4",
                "value": 1
              },
              {
                "id": "2",
                "next": "5",
                "prev": "1",
                "value": 2
              },
              {
                "id": "5",
                "next": "3",
                "prev": "2",
                "value": 5
              },
              {
                "id": "3",
                "next": "6",
                "prev": "5",
                "value": 3
              },
              {
                "id": "6",
                "next": "3-2",
                "prev": "3",
                "value": 6
              },
              {
                "id": "3-2",
                "next": null,
                "prev": "6",
                "value": 3
              }
            ],
            "tail": "3-2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            1,
            "3-3"
          ],
          "linkedList": {
            "head": "3",
            "nodes": [
              {
                "id": "3",
                "next": "4",
                "prev": null,
                "value": 3
              },
              {
                "id": "4",
                "next": "1",
                "prev": "3",
                "value": 4
              },
              {
                "id": "1",
                "next": "2",
                "prev": "4",
                "value": 1
              },
              {
                "id": "2",
                "next": "5",
                "prev": "1",
                "value": 2
              },
              {
                "id": "5",
                "next": "3-2",
                "prev": "2",
                "value": 5
              },
              {
                "id": "3-2",
                "next": "6",
                "prev": "5",
                "value": 3
              },
              {
                "id": "6",
                "next": "3-3",
                "prev": "3-2",
                "value": 6
              },
              {
                "id": "3-3",
                "next": null,
                "prev": "6",
                "value": 3
              }
            ],
            "tail": "3-3"
          },
          "method": "insertAtPosition",
          "output": null
        },
        {
          "arguments": [
            3
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "1",
                "prev": null,
                "value": 4
              },
              {
                "id": "1",
                "next": "2",
                "prev": "4",
                "value": 1
              },
              {
                "id": "2",
                "next": "5",
                "prev": "1",
                "value": 2
              },
              {
                "id": "5",
                "next": "6",
                "prev": "2",
                "value": 5
              },
              {
                "id": "6",
                "next": null,
                "prev": "5",
                "value": 6
              }
            ],
            "tail": "6"
          },
          "method": "removeNodesWithValue",
          "output": null
        },
        {
          "arguments": [
            "2"
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "1",
                "prev": null,
                "value": 4
              },
              {
                "id": "1",
                "next": "5",
                "prev": "4",
                "value": 1
              },
              {
                "id": "5",
                "next": "6",
                "prev": "1",
                "value": 5
              },
              {
                "id": "6",
                "next": null,
                "prev": "5",
                "value": 6
              }
            ],
            "tail": "6"
          },
          "method": "remove",
          "output": null
        },
        {
          "arguments": [
            5
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "1",
                "prev": null,
                "value": 4
              },
              {
                "id": "1",
                "next": "5",
                "prev": "4",
                "value": 1
              },
              {
                "id": "5",
                "next": "6",
                "prev": "1",
                "value": 5
              },
              {
                "id": "6",
                "next": null,
                "prev": "5",
                "value": 6
              }
            ],
            "tail": "6"
          },
          "method": "containsNodeWithValue",
          "output": true
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setTail",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            1,
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "insertAtPosition",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "setTail",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "2"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "1",
                "prev": null,
                "value": 2
              },
              {
                "id": "1",
                "next": null,
                "prev": "2",
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "1",
                "prev": null,
                "value": 2
              },
              {
                "id": "1",
                "next": null,
                "prev": "2",
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "insertBefore",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": null,
                "prev": "2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setTail",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "1",
                "prev": null,
                "value": 2
              },
              {
                "id": "1",
                "next": null,
                "prev": "2",
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "insertBefore",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "3",
            "nodes": [
              {
                "id": "3",
                "next": "2",
                "prev": null,
                "value": 3
              },
              {
                "id": "2",
                "next": "1",
                "prev": "3",
                "value": 2
              },
              {
                "id": "1",
                "next": null,
                "prev": "2",
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "insertBefore",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "3",
                "prev": null,
                "value": 4
              },
              {
                "id": "3",
                "next": "2",
                "prev": "4",
                "value": 3
              },
              {
                "id": "2",
                "next": "1",
                "prev": "3",
                "value": 2
              },
              {
                "id": "1",
                "next": null,
                "prev": "2",
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "insertBefore",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": null,
                "prev": "2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "3",
                "prev": null,
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "1",
                "prev": "3",
                "value": 4
              },
              {
                "id": "1",
                "next": null,
                "prev": "4",
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setTail",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setTail",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "1",
                "prev": null,
                "value": 2
              },
              {
                "id": "1",
                "next": null,
                "prev": "2",
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "insertBefore",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "3",
            "nodes": [
              {
                "id": "3",
                "next": "2",
                "prev": null,
                "value": 3
              },
              {
                "id": "2",
                "next": "1",
                "prev": "3",
                "value": 2
              },
              {
                "id": "1",
                "next": null,
                "prev": "2",
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "insertBefore",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "4",
            "nodes": [
              {
                "id": "4",
                "next": "3",
                "prev": null,
                "value": 4
              },
              {
                "id": "3",
                "next": "2",
                "prev": "4",
                "value": 3
              },
              {
                "id": "2",
                "next": "1",
                "prev": "3",
                "value": 2
              },
              {
                "id": "1",
                "next": null,
                "prev": "2",
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "insertBefore",
          "output": null
        },
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "4",
                "prev": null,
                "value": 1
              },
              {
                "id": "4",
                "next": "3",
                "prev": "1",
                "value": 4
              },
              {
                "id": "3",
                "next": "2",
                "prev": "4",
                "value": 3
              },
              {
                "id": "2",
                "next": null,
                "prev": "3",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "setHead",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": null,
                "prev": "2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "1"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "1",
                "prev": null,
                "value": 2
              },
              {
                "id": "1",
                "next": "3",
                "prev": "2",
                "value": 1
              },
              {
                "id": "3",
                "next": "4",
                "prev": "1",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "1",
                "prev": null,
                "value": 2
              },
              {
                "id": "1",
                "next": "4",
                "prev": "2",
                "value": 1
              },
              {
                "id": "4",
                "next": "3",
                "prev": "1",
                "value": 4
              },
              {
                "id": "3",
                "next": null,
                "prev": "4",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertBefore",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": null,
                "prev": "2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "4",
            "5"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": null,
                "prev": "4",
                "value": 5
              }
            ],
            "tail": "5"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "5",
            "6"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": "6",
                "prev": "4",
                "value": 5
              },
              {
                "id": "6",
                "next": null,
                "prev": "5",
                "value": 6
              }
            ],
            "tail": "6"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "6",
            "7"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": "6",
                "prev": "4",
                "value": 5
              },
              {
                "id": "6",
                "next": "7",
                "prev": "5",
                "value": 6
              },
              {
                "id": "7",
                "next": null,
                "prev": "6",
                "value": 7
              }
            ],
            "tail": "7"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            7,
            "1"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "3",
                "prev": null,
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": "6",
                "prev": "4",
                "value": 5
              },
              {
                "id": "6",
                "next": "1",
                "prev": "5",
                "value": 6
              },
              {
                "id": "1",
                "next": "7",
                "prev": "6",
                "value": 1
              },
              {
                "id": "7",
                "next": null,
                "prev": "1",
                "value": 7
              }
            ],
            "tail": "7"
          },
          "method": "insertAtPosition",
          "output": null
        },
        {
          "arguments": [
            1,
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": "6",
                "prev": "4",
                "value": 5
              },
              {
                "id": "6",
                "next": "7",
                "prev": "5",
                "value": 6
              },
              {
                "id": "7",
                "next": null,
                "prev": "6",
                "value": 7
              }
            ],
            "tail": "7"
          },
          "method": "insertAtPosition",
          "output": null
        },
        {
          "arguments": [
            2,
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": "6",
                "prev": "4",
                "value": 5
              },
              {
                "id": "6",
                "next": "7",
                "prev": "5",
                "value": 6
              },
              {
                "id": "7",
                "next": null,
                "prev": "6",
                "value": 7
              }
            ],
            "tail": "7"
          },
          "method": "insertAtPosition",
          "output": null
        },
        {
          "arguments": [
            3,
            "1"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "1",
                "prev": null,
                "value": 2
              },
              {
                "id": "1",
                "next": "3",
                "prev": "2",
                "value": 1
              },
              {
                "id": "3",
                "next": "4",
                "prev": "1",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": "6",
                "prev": "4",
                "value": 5
              },
              {
                "id": "6",
                "next": "7",
                "prev": "5",
                "value": 6
              },
              {
                "id": "7",
                "next": null,
                "prev": "6",
                "value": 7
              }
            ],
            "tail": "7"
          },
          "method": "insertAtPosition",
          "output": null
        },
        {
          "arguments": [
            4,
            "1"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "3",
                "prev": null,
                "value": 2
              },
              {
                "id": "3",
                "next": "1",
                "prev": "2",
                "value": 3
              },
              {
                "id": "1",
                "next": "4",
                "prev": "3",
                "value": 1
              },
              {
                "id": "4",
                "next": "5",
                "prev": "1",
                "value": 4
              },
              {
                "id": "5",
                "next": "6",
                "prev": "4",
                "value": 5
              },
              {
                "id": "6",
                "next": "7",
                "prev": "5",
                "value": 6
              },
              {
                "id": "7",
                "next": null,
                "prev": "6",
                "value": 7
              }
            ],
            "tail": "7"
          },
          "method": "insertAtPosition",
          "output": null
        },
        {
          "arguments": [
            5,
            "1"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "3",
                "prev": null,
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "1",
                "prev": "3",
                "value": 4
              },
              {
                "id": "1",
                "next": "5",
                "prev": "4",
                "value": 1
              },
              {
                "id": "5",
                "next": "6",
                "prev": "1",
                "value": 5
              },
              {
                "id": "6",
                "next": "7",
                "prev": "5",
                "value": 6
              },
              {
                "id": "7",
                "next": null,
                "prev": "6",
                "value": 7
              }
            ],
            "tail": "7"
          },
          "method": "insertAtPosition",
          "output": null
        },
        {
          "arguments": [
            6,
            "1"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "3",
                "prev": null,
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": "5",
                "prev": "3",
                "value": 4
              },
              {
                "id": "5",
                "next": "1",
                "prev": "4",
                "value": 5
              },
              {
                "id": "1",
                "next": "6",
                "prev": "5",
                "value": 1
              },
              {
                "id": "6",
                "next": "7",
                "prev": "1",
                "value": 6
              },
              {
                "id": "7",
                "next": null,
                "prev": "6",
                "value": 7
              }
            ],
            "tail": "7"
          },
          "method": "insertAtPosition",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": null,
            "nodes": [],
            "tail": null
          },
          "method": "remove",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            1
          ],
          "linkedList": {
            "head": null,
            "nodes": [],
            "tail": null
          },
          "method": "removeNodesWithValue",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": null,
                "prev": "2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "3",
                "prev": null,
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "remove",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": null,
                "prev": "2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": null,
                "prev": "2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "remove",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": null,
                "prev": "2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "3",
                "prev": null,
                "value": 1
              },
              {
                "id": "3",
                "next": "4",
                "prev": "1",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "remove",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "1-2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "1-2",
                "prev": null,
                "value": 1
              },
              {
                "id": "1-2",
                "next": null,
                "prev": "1",
                "value": 1
              }
            ],
            "tail": "1-2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "1-2",
            "1-3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "1-2",
                "prev": null,
                "value": 1
              },
              {
                "id": "1-2",
                "next": "1-3",
                "prev": "1",
                "value": 1
              },
              {
                "id": "1-3",
                "next": null,
                "prev": "1-2",
                "value": 1
              }
            ],
            "tail": "1-3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "1-3",
            "1-4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "1-2",
                "prev": null,
                "value": 1
              },
              {
                "id": "1-2",
                "next": "1-3",
                "prev": "1",
                "value": 1
              },
              {
                "id": "1-3",
                "next": "1-4",
                "prev": "1-2",
                "value": 1
              },
              {
                "id": "1-4",
                "next": null,
                "prev": "1-3",
                "value": 1
              }
            ],
            "tail": "1-4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            1
          ],
          "linkedList": {
            "head": null,
            "nodes": [],
            "tail": null
          },
          "method": "removeNodesWithValue",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "1-2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "1-2",
                "prev": "1",
                "value": 2
              },
              {
                "id": "1-2",
                "next": null,
                "prev": "2",
                "value": 1
              }
            ],
            "tail": "1-2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "1-2",
            "3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "1-2",
                "prev": "1",
                "value": 2
              },
              {
                "id": "1-2",
                "next": "3",
                "prev": "2",
                "value": 1
              },
              {
                "id": "3",
                "next": null,
                "prev": "1-2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "1-3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "1-2",
                "prev": "1",
                "value": 2
              },
              {
                "id": "1-2",
                "next": "3",
                "prev": "2",
                "value": 1
              },
              {
                "id": "3",
                "next": "1-3",
                "prev": "1-2",
                "value": 3
              },
              {
                "id": "1-3",
                "next": null,
                "prev": "3",
                "value": 1
              }
            ],
            "tail": "1-3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "1-3",
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "1-2",
                "prev": "1",
                "value": 2
              },
              {
                "id": "1-2",
                "next": "3",
                "prev": "2",
                "value": 1
              },
              {
                "id": "3",
                "next": "1-3",
                "prev": "1-2",
                "value": 3
              },
              {
                "id": "1-3",
                "next": "4",
                "prev": "3",
                "value": 1
              },
              {
                "id": "4",
                "next": null,
                "prev": "1-3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            1
          ],
          "linkedList": {
            "head": "2",
            "nodes": [
              {
                "id": "2",
                "next": "3",
                "prev": null,
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "removeNodesWithValue",
          "output": null
        }
      ],
      [
        {
          "arguments": [
            "1"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": null,
                "prev": null,
                "value": 1
              }
            ],
            "tail": "1"
          },
          "method": "setHead",
          "output": null
        },
        {
          "arguments": [
            "1",
            "2"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": null,
                "prev": "1",
                "value": 2
              }
            ],
            "tail": "2"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "2",
            "3"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": null,
                "prev": "2",
                "value": 3
              }
            ],
            "tail": "3"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            "3",
            "4"
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "insertAfter",
          "output": null
        },
        {
          "arguments": [
            1
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "containsNodeWithValue",
          "output": true
        },
        {
          "arguments": [
            2
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "containsNodeWithValue",
          "output": true
        },
        {
          "arguments": [
            3
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "containsNodeWithValue",
          "output": true
        },
        {
          "arguments": [
            4
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "containsNodeWithValue",
          "output": true
        },
        {
          "arguments": [
            5
          ],
          "linkedList": {
            "head": "1",
            "nodes": [
              {
                "id": "1",
                "next": "2",
                "prev": null,
                "value": 1
              },
              {
                "id": "2",
                "next": "3",
                "prev": "1",
                "value": 2
              },
              {
                "id": "3",
                "next": "4",
                "prev": "2",
                "value": 3
              },
              {
                "id": "4",
                "next": null,
                "prev": "3",
                "value": 4
              }
            ],
            "tail": "4"
          },
          "method": "containsNodeWithValue",
          "output": false
        }
      ]
    ]
  ]
}