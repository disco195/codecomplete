{
  "Summary": {
    "Name": "Multi String Search",
    "Category": "Tries",
    "Difficulty": 3,
    "Available": true,
    "Metadata": {
      "number": 202,
      "timeOne": 0,
      "timeTwo": 2596,
      "url": "https://player.vimeo.com/video/264054526"
    }
  },
  "Prompt": "",
  "Hints": "A simple way to solve this problem is to iterate through all of the small strings, checking if each of them is contained in the big string by iterating through the big string's characters and comparing them to the given small string's characters with a couple of loops. Is this approach efficient from a time-complexity point of view?\nTry building a suffix-trie-like data structure containing all of the big string's suffixes. Then, iterate through all of the small strings and check if each of them is contained in the data structure you've created. What are the time-complexity ramifications of this approach?\nTry building a trie containing all of the small strings. Then, iterate through the big string's characters and check if any part of the big string is a string contained in the trie you've created. Is this approach better than the one described in Hint #2 from a time-complexity point of view?\n",
  "SpaceTime": "O(ns + bs) time | O(ns) space - where n is the number of small strings, s is the length of longest small string, and b is the length of the big string\n",
  "PromptHTML": "<p>\n  Write a function that takes in a big string and an array of small strings,\n  all of which are smaller in length than the big string. The function should\n  return an array of booleans, where each boolean represents whether the small\n  string at that index in the array of small strings is contained in the big\n  string.\n</p>\n<p>Note that you can't use language-built-in string-matching methods.</p>\n<h3>Sample Input</h3>\n<pre>\n<span class=\"CodeEditor-promptParameter\">bigString</span> = \"this is a big string\"\n<span class=\"CodeEditor-promptParameter\">smallStrings</span> = [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]\n</pre>\n<h3>Sample Output</h3>\n<pre>\n[true, false, true, true, false, true, false]\n</pre>\n",
  "Notes": "",
  "IsLongOutput": false,
  "Visualization": {
    "inputType": null,
    "outputType": null
  },
  "CustomInputLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "CustomInputVars": [
    {
      "Name": "bigString",
      "Example": "this is a big string",
      "Schema": {
        "type": "string"
      }
    },
    {
      "Name": "smallStrings",
      "Example": [
        "this",
        "yo",
        "is",
        "a",
        "bigger",
        "string",
        "kappa"
      ],
      "Schema": {
        "items": {
          "type": "string"
        },
        "type": "array"
      }
    }
  ],
  "Resources": {
    "cpp": {
      "Language": "cpp",
      "StartingCode": "#include <vector>\nusing namespace std;\n\nvector<bool> multiStringSearch(string bigString, vector<string> smallStrings) {\n  // Write your code here.\n  return {};\n}\n",
      "StartingTest": "class ProgramTest : public TestSuite {\npublic:\n  void Run() {\n\n    RunTest(\"Test Case 1\", []() {\n      vector<bool> expected{true, false, true, true, false, true, false};\n      assert(multiStringSearch(\"this is a big string\",\n                               {\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\",\n                                \"kappa\"}) == expected);\n    });\n\n    RunTest(\"Test Case 2\", []() {\n      vector<bool> expected{true, true, false, true, true, false, false};\n      assert(multiStringSearch(\"Mary goes to the shopping center every week.\",\n                               {\"to\", \"Mary\", \"centers\", \"shop\", \"shopping\",\n                                \"string\", \"kappa\"}) == expected);\n    });\n\n    RunTest(\"Test Case 3\", []() {\n      vector<bool> expected{false, false, false, false, true, false, false};\n      assert(multiStringSearch(\n                 \"adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda\",\n                 {\"abcd\", \"acbd\", \"adbc\", \"dabc\", \"cbda\", \"cabd\", \"cdab\"}) ==\n             expected);\n    });\n\n    RunTest(\"Test Case 4\", []() {\n      vector<bool> expected{true, false, false, false, true, true};\n      assert(\n          multiStringSearch(\"test testing testings tests testers test-takers\",\n                            {\"tests\", \"testatk\", \"testiing\", \"trsatii\",\n                             \"test-taker\", \"test\"}) == expected);\n    });\n\n    RunTest(\"Test Case 5\", []() {\n      vector<bool> expected{false, false, false, false, false, false, true};\n      assert(multiStringSearch(\"ndbajwhfawkjljkfaopwdlaawjk dawkj \"\n                               \"awjkawkfjhkawk ahjwkjad jadfljawd\",\n                               {\"abc\", \"akwbc\", \"awbc\", \"abafac\", \"ajjfbc\",\n                                \"abac\", \"jadfl\"}) == expected);\n    });\n\n    RunTest(\"Test Case 6\", []() {\n      vector<bool> expected{false, true,  false, false, false,\n                            false, false, true,  true};\n      assert(multiStringSearch(\"Is this particular test going to pass or is it \"\n                               \"going to fail? That is the question.\",\n                               {\"that\", \"the\", \"questions\", \"goes\", \"mountain\",\n                                \"passes\", \"passed\", \"going\", \"is\"}) ==\n             expected);\n    });\n\n    RunTest(\"Test Case 7\", []() {\n      vector<bool> expected{false, false, false, false, false, false};\n      assert(multiStringSearch(\"Everything in this test should fail.\",\n                               {\"everything\", \"inn\", \"that\", \"testers\", \"shall\",\n                                \"failure\"}) == expected);\n    });\n  }\n};\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest : public TestSuite {\npublic:\n  void Run() {\n    RunTest(\"Test Case 1\", []() {\n      vector<bool> expected{true, false, true, true, false, true, false};\n      assert(multiStringSearch(\"this is a big string\",\n                               {\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\",\n                                \"kappa\"}) == expected);\n    });\n  }\n};\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n#include <vector>\nusing namespace std;\n\nbool isInBigString(string bigString, string smallString);\nbool isInBigStringHelper(string bigString, string smallString, int startIdx);\n\n// O(bns) time | O(n) space\nvector<bool> multiStringSearch(string bigString, vector<string> smallStrings) {\n  vector<bool> solution;\n  for (string smallString : smallStrings) {\n    solution.push_back(isInBigString(bigString, smallString));\n  }\n  return solution;\n}\n\nbool isInBigString(string bigString, string smallString) {\n  for (int i = 0; i < bigString.length(); i++) {\n    if (i + smallString.length() > bigString.length()) {\n      break;\n    }\n    if (isInBigStringHelper(bigString, smallString, i)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool isInBigStringHelper(string bigString, string smallString, int startIdx) {\n  int leftBigIdx = startIdx;\n  int rightBigIdx = startIdx + smallString.length() - 1;\n  int leftSmallIdx = 0;\n  int rightSmallIdx = smallString.length() - 1;\n  while (leftBigIdx <= rightBigIdx) {\n    if (bigString[leftBigIdx] != smallString[leftSmallIdx] ||\n        bigString[rightBigIdx] != smallString[rightSmallIdx]) {\n      return false;\n    }\n    leftBigIdx++;\n    rightBigIdx--;\n    leftSmallIdx++;\n    rightSmallIdx--;\n  }\n  return true;\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass TrieNode {\npublic:\n  unordered_map<char, TrieNode *> children;\n};\n\nclass ModifiedSuffixTrie {\npublic:\n  TrieNode *root;\n\n  ModifiedSuffixTrie(string str) {\n    this->root = new TrieNode();\n    this->populateModifiedSuffixTrieFrom(str);\n  }\n\n  void populateModifiedSuffixTrieFrom(string str) {\n    for (int i = 0; i < str.length(); i++) {\n      this->insertSubstringStartingAt(i, str);\n    }\n  }\n\n  void insertSubstringStartingAt(int i, string str) {\n    TrieNode *node = this->root;\n    for (int j = i; j < str.length(); j++) {\n      char letter = str[j];\n      if (node->children.find(letter) == node->children.end()) {\n        TrieNode *newNode = new TrieNode();\n        node->children.insert({letter, newNode});\n      }\n      node = node->children[letter];\n    }\n  }\n\n  bool contains(string str) {\n    TrieNode *node = this->root;\n    for (char letter : str) {\n      if (node->children.find(letter) == node->children.end()) {\n        return false;\n      }\n      node = node->children[letter];\n    }\n    return true;\n  }\n};\n\n// O(b^2 + ns) time | O(b^2 + n) space\nvector<bool> multiStringSearch(string bigString, vector<string> smallStrings) {\n  ModifiedSuffixTrie modifiedSuffixTrie(bigString);\n  vector<bool> solution;\n  for (string smallString : smallStrings) {\n    solution.push_back(modifiedSuffixTrie.contains(smallString));\n  }\n  return solution;\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass TrieNode {\npublic:\n  unordered_map<char, TrieNode *> children;\n  string word;\n};\n\nclass Trie {\npublic:\n  TrieNode *root;\n  char endSymbol;\n\n  Trie() {\n    this->root = new TrieNode();\n    this->endSymbol = '*';\n  }\n\n  void insert(string str) {\n    TrieNode *current = this->root;\n    for (int i = 0; i < str.length(); i++) {\n      char letter = str[i];\n      if (current->children.find(letter) == current->children.end()) {\n        TrieNode *newNode = new TrieNode();\n        current->children.insert({letter, newNode});\n      }\n      current = current->children[letter];\n    }\n    current->children.insert({this->endSymbol, NULL});\n    current->word = str;\n  }\n};\n\nvoid findSmallStringsIn(string str, int startIdx, Trie *trie,\n                        unordered_map<string, bool> *containedStrings);\n\n// O(ns + bs) time | O(ns) space\nvector<bool> multiStringSearch(string bigString, vector<string> smallStrings) {\n  Trie *trie = new Trie();\n  for (string smallString : smallStrings) {\n    trie->insert(smallString);\n  }\n  unordered_map<string, bool> containedStrings;\n  for (int i = 0; i < bigString.length(); i++) {\n    findSmallStringsIn(bigString, i, trie, &containedStrings);\n  }\n  vector<bool> solution;\n  for (string smallString : smallStrings) {\n    solution.push_back(containedStrings.find(smallString) !=\n                       containedStrings.end());\n  }\n  return solution;\n}\n\nvoid findSmallStringsIn(string str, int startIdx, Trie *trie,\n                        unordered_map<string, bool> *containedStrings) {\n  TrieNode *currentNode = trie->root;\n  for (int i = startIdx; i < str.length(); i++) {\n    if (currentNode->children.find(str[i]) == currentNode->children.end()) {\n      break;\n    }\n    currentNode = currentNode->children[str[i]];\n    if (currentNode->children.find(trie->endSymbol) !=\n        currentNode->children.end()) {\n      containedStrings->insert({currentNode->word, true});\n    }\n  }\n}\n"
      ]
    },
    "csharp": {
      "Language": "csharp",
      "StartingCode": "using System.Collections.Generic;\n\npublic class Program {\n\tpublic static List<bool> MultistringSearch(string bigstring, string[] smallstrings) {\n\t\t// Write your code here.\n\t\treturn null;\n\t}\n}\n",
      "StartingTest": "using System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tbool[] expected = {true, false, true, true, false, true, false};\n\t\tList<bool> output = Program.MultistringSearch(\"this is a big string\",\n\t\t    new string[] {\"this\", \"yo\", \"is\", \"a\",\n\t\t                  \"bigger\", \"string\",\n\t\t                  \"kappa\"});\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase2() {\n\t\tbool[] expected = {true, true, false, true, true, false, false};\n\t\tList<bool> output = Program.MultistringSearch(\n\t\t\t\"Mary goes to the shopping center every week.\", new string[] {\"to\", \"Mary\",\n\t\t\t                                                              \"centers\",\n\t\t\t                                                              \"shop\",\n\t\t\t                                                              \"shopping\",\n\t\t\t                                                              \"string\",\n\t\t\t                                                              \"kappa\"});\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase3() {\n\t\tbool[] expected = {false, false, false, false, true, false, false};\n\t\tList<bool> output = Program.MultistringSearch(\n\t\t\t\"adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda\", new string[] {\"abcd\",\n\t\t\t                                                                  \"acbd\",\n\t\t\t                                                                  \"adbc\",\n\t\t\t                                                                  \"dabc\",\n\t\t\t                                                                  \"cbda\",\n\t\t\t                                                                  \"cabd\",\n\t\t\t                                                                  \"cdab\"});\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase4() {\n\t\tbool[] expected = {true, false, false, false, true, true};\n\t\tList<bool> output = Program.MultistringSearch(\n\t\t\t\"test testing testings tests testers test-takers\", new string[] {\"tests\",\n\t\t\t                                                                 \"testatk\",\n\t\t\t                                                                 \"testiing\",\n\t\t\t                                                                 \"trsatii\",\n\t\t\t                                                                 \"test-taker\",\n\t\t\t                                                                 \"test\"});\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase5() {\n\t\tbool[] expected = {false, false, false, false, false, false, true};\n\t\tList<bool> output = Program.MultistringSearch(\n\t\t\t\"ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd\",\n\t\t\tnew string[] {\"abc\", \"akwbc\", \"awbc\", \"abafac\", \"ajjfbc\", \"abac\", \"jadfl\"});\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase6() {\n\t\tbool[] expected = {false, true, false, false, false, false, false, true, true};\n\t\tList<bool> output = Program.MultistringSearch(\n\t\t\t\"Is this particular test going to pass or is it going to fail? That is the question.\",\n\t\t\tnew string[] {\"that\", \"the\", \"questions\", \"goes\", \"mountain\", \"passes\", \"passed\",\n\t\t\t              \"going\",\n\t\t\t              \"is\"});\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\t[Test]\n\tpublic void TestCase7() {\n\t\tbool[] expected = {false, false, false, false, false, false};\n\t\tList<bool> output = Program.MultistringSearch(\n\t\t\t\"Everything in this test should fail.\", new string[] {\"everything\", \"inn\",\n\t\t\t                                                      \"that\", \"testers\",\n\t\t\t                                                      \"shall\", \"failure\"});\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\tpublic bool compare(List<bool> arr1, bool[] arr2) {\n\t\tif (arr1.Count != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nusing System.Collections.Generic;\n\npublic class ProgramTest {\n\t[Test]\n\tpublic void TestCase1() {\n\t\tbool[] expected = {true, false, true, true, false, true, false};\n\t\tList<bool> output = Program.MultistringSearch(\"this is a big string\",\n\t\t    new string[] {\"this\", \"yo\", \"is\", \"a\",\n\t\t                  \"bigger\", \"string\",\n\t\t                  \"kappa\"});\n\t\tUtils.AssertTrue(compare(output, expected));\n\t}\n\n\tpublic bool compare(List<bool> arr1, bool[] arr2) {\n\t\tif (arr1.Count != arr2.Length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < arr1.Count; i++) {\n\t\t\tif (arr1[i] != arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(bns) time | O(n) space\n\tpublic static List<bool> MultistringSearch(string bigstring, string[] smallstrings) {\n\t\tList<bool> solution = new List<bool>();\n\t\tforeach (string smallstring in smallstrings) {\n\t\t\tsolution.Add(isInBigstring(bigstring, smallstring));\n\t\t}\n\t\treturn solution;\n\t}\n\n\tpublic static bool isInBigstring(string bigstring, string smallstring) {\n\t\tfor (int i = 0; i < bigstring.Length; i++) {\n\t\t\tif (i + smallstring.Length > bigstring.Length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isInBigstring(bigstring, smallstring, i)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static bool isInBigstring(string bigstring, string smallstring, int startIdx) {\n\t\tint leftBigIdx = startIdx;\n\t\tint rightBigIdx = startIdx + smallstring.Length - 1;\n\t\tint leftSmallIdx = 0;\n\t\tint rightSmallIdx = smallstring.Length - 1;\n\t\twhile (leftBigIdx <= rightBigIdx) {\n\t\t\tif (\n\t\t\t\tbigstring[leftBigIdx] != smallstring[leftSmallIdx] ||\n\t\t\t\tbigstring[rightBigIdx] != smallstring[rightSmallIdx]\n\t\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tleftBigIdx++;\n\t\t\trightBigIdx--;\n\t\t\tleftSmallIdx++;\n\t\t\trightSmallIdx--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(b^2 + ns) time | O(b^2 + n) space\n\tpublic static List<bool> MultistringSearch(string bigstring, string[] smallstrings) {\n\t\tModifiedSuffixTrie modifiedSuffixTrie = new ModifiedSuffixTrie(bigstring);\n\t\tList<bool> solution = new List<bool>();\n\t\tforeach (string smallstring in smallstrings) {\n\t\t\tsolution.Add(modifiedSuffixTrie.Contains(smallstring));\n\t\t}\n\t\treturn solution;\n\t}\n\n\tpublic class TrieNode {\n\t\tpublic Dictionary<char, TrieNode> children = new Dictionary<char, TrieNode>();\n\t}\n\n\tpublic class ModifiedSuffixTrie {\n\t\tTrieNode root = new TrieNode();\n\n\t\tpublic ModifiedSuffixTrie(string str) {\n\t\t\tpopulateModifiedSuffixTrieFrom(str);\n\t\t}\n\n\t\tpublic void populateModifiedSuffixTrieFrom(string str) {\n\t\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\t\tinsertSubstringStartingAt(i, str);\n\t\t\t}\n\t\t}\n\n\t\tpublic void insertSubstringStartingAt(int i, string str) {\n\t\t\tTrieNode node = root;\n\t\t\tfor (int j = i; j < str.Length; j++) {\n\t\t\t\tchar letter = str[j];\n\t\t\t\tif (!node.children.ContainsKey(letter)) {\n\t\t\t\t\tTrieNode newNode = new TrieNode();\n\t\t\t\t\tnode.children.Add(letter, newNode);\n\t\t\t\t}\n\t\t\t\tnode = node.children[letter];\n\t\t\t}\n\t\t}\n\n\t\tpublic bool Contains(string str) {\n\t\t\tTrieNode node = root;\n\t\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\t\tchar letter = str[i];\n\t\t\t\tif (!node.children.ContainsKey(letter)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tnode = node.children[letter];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nusing System.Collections.Generic;\n\npublic class Program {\n\t// O(ns + bs) time | O(ns) space\n\tpublic static List<bool> MultistringSearch(string bigstring, string[] smallstrings) {\n\t\tTrie trie = new Trie();\n\t\tforeach (string smallstring in smallstrings) {\n\t\t\ttrie.insert(smallstring);\n\t\t}\n\t\tHashSet<string> containedstrings = new HashSet<string>();\n\t\tfor (int i = 0; i < bigstring.Length; i++) {\n\t\t\tfindSmallstringsIn(bigstring, i, trie, containedstrings);\n\t\t}\n\t\tList<bool> solution = new List<bool>();\n\t\tforeach (string str in smallstrings) {\n\t\t\tsolution.Add(containedstrings.Contains(str));\n\t\t}\n\t\treturn solution;\n\t}\n\n\tpublic static void findSmallstringsIn(string str, int startIdx, Trie trie,\n\t  HashSet<string> containedstrings) {\n\t\tTrieNode currentNode = trie.root;\n\t\tfor (int i = startIdx; i < str.Length; i++) {\n\t\t\tchar currentChar = str[i];\n\t\t\tif (!currentNode.children.ContainsKey(currentChar)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrentNode = currentNode.children[currentChar];\n\t\t\tif (currentNode.children.ContainsKey(trie.endSymbol)) {\n\t\t\t\tcontainedstrings.Add(currentNode.word);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic class TrieNode {\n\t\tpublic Dictionary<char, TrieNode> children = new Dictionary<char, TrieNode>();\n\t\tpublic string word;\n\t}\n\n\tpublic class Trie {\n\t\tpublic TrieNode root = new TrieNode();\n\t\tpublic char endSymbol = '*';\n\n\t\tpublic void insert(string str) {\n\t\t\tTrieNode node = root;\n\t\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\t\tchar letter = str[i];\n\t\t\t\tif (!node.children.ContainsKey(letter)) {\n\t\t\t\t\tTrieNode newNode = new TrieNode();\n\t\t\t\t\tnode.children.Add(letter, newNode);\n\t\t\t\t}\n\t\t\t\tnode = node.children[letter];\n\t\t\t}\n\t\t\tnode.children[endSymbol] = null;\n\t\t\tnode.word = str;\n\t\t}\n\t}\n}\n"
      ]
    },
    "go": {
      "Language": "go",
      "StartingCode": "package main\n\nfunc MultiStringSearch(bigString string, smallStrings []string) []bool {\n\t// Write your code here.\n\treturn nil\n}\n",
      "StartingTest": "package main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []bool{true, false, true, true, false, true, false}\n\toutput := MultiStringSearch(\"this is a big string\", []string{\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"})\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase2(t *TestCase) {\n\texpected := []bool{true, true, false, true, true, false, false}\n\toutput := MultiStringSearch(\"Mary goes to the shopping center every week.\", []string{\"to\", \"Mary\", \"centers\", \"shop\", \"shopping\", \"string\", \"kappa\"})\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase3(t *TestCase) {\n\texpected := []bool{false, false, false, false, true, false, false}\n\toutput := MultiStringSearch(\"adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda\", []string{\"abcd\", \"acbd\", \"adbc\", \"dabc\", \"cbda\", \"cabd\", \"cdab\"})\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase4(t *TestCase) {\n\texpected := []bool{true, false, false, false, true, true}\n\toutput := MultiStringSearch(\"test testing testings tests testers test-takers\", []string{\"tests\", \"testatk\", \"testiing\", \"trsatii\", \"test-taker\", \"test\"})\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase5(t *TestCase) {\n\texpected := []bool{false, false, false, false, false, false, true}\n\toutput := MultiStringSearch(\"ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd\", []string{\"abc\", \"akwbc\", \"awbc\", \"abafac\", \"ajjfbc\", \"abac\", \"jadfl\"})\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase6(t *TestCase) {\n\texpected := []bool{false, true, false, false, false, false, false, true, true}\n\toutput := MultiStringSearch(\"Is this particular test going to pass or is it going to fail? That is the question.\", []string{\"that\", \"the\", \"questions\", \"goes\", \"mountain\", \"passes\", \"passed\", \"going\", \"is\"})\n\trequire.Equal(t, expected, output)\n}\n\nfunc (s *TestSuite) TestCase7(t *TestCase) {\n\texpected := []bool{false, false, false, false, false, false}\n\toutput := MultiStringSearch(\"Everything in this test should fail.\", []string{\"everything\", \"inn\", \"that\", \"testers\", \"shall\", \"failure\"})\n\trequire.Equal(t, expected, output)\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\npackage main\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (s *TestSuite) TestCase1(t *TestCase) {\n\texpected := []bool{true, false, true, true, false, true, false}\n\toutput := MultiStringSearch(\"this is a big string\", []string{\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"})\n\trequire.Equal(t, expected, output)\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\npackage main\n\n// O(bns) time | O(n) space\nfunc MultiStringSearch(bigString string, smallStrings []string) []bool {\n\toutput := make([]bool, len(smallStrings))\n\tfor i, smallString := range smallStrings {\n\t\toutput[i] = isInBigString(bigString, smallString)\n\t}\n\treturn output\n}\n\nfunc isInBigString(bigString, smallString string) bool {\n\tfor i := range bigString {\n\t\tif i+len(smallString) > len(bigString) {\n\t\t\tbreak\n\t\t}\n\t\tif isInBigStringHelper(bigString, smallString, i) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isInBigStringHelper(bigString, smallString string, startIdx int) bool {\n\tleftBigIdx := startIdx\n\trightBigIdx := startIdx + len(smallString) - 1\n\tleftSmallIdx := 0\n\trightSmallIdx := len(smallString) - 1\n\tfor leftBigIdx <= rightBigIdx {\n\t\tif bigString[leftBigIdx] != smallString[leftSmallIdx] ||\n\t\t\tbigString[rightBigIdx] != smallString[rightSmallIdx] {\n\t\t\treturn false\n\t\t}\n\t\tleftBigIdx += 1\n\t\trightBigIdx -= 1\n\t\tleftSmallIdx += 1\n\t\trightSmallIdx -= 1\n\t}\n\treturn true\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\npackage main\n\n// O(b^2 + ns) time | O(b^2 + n) space\nfunc MultiStringSearch(bigString string, smallStrings []string) []bool {\n\ttrie := NewTrie(bigString)\n\toutput := make([]bool, len(smallStrings))\n\tfor i, smallString := range smallStrings {\n\t\toutput[i] = trie.Contains(smallString)\n\t}\n\treturn output\n}\n\ntype ModifiedSuffixTrie map[byte]ModifiedSuffixTrie\n\nfunc NewTrie(str string) ModifiedSuffixTrie {\n\ttrie := ModifiedSuffixTrie{}\n\tfor i := range str {\n\t\ttrie.Add(str, i)\n\t}\n\treturn trie\n}\n\nfunc (trie ModifiedSuffixTrie) Add(str string, startIndex int) {\n\tnode := trie\n\tfor j := startIndex; j < len(str); j++ {\n\t\tletter := str[j]\n\t\tif _, found := node[letter]; !found {\n\t\t\tnode[letter] = ModifiedSuffixTrie{}\n\t\t}\n\t\tnode = node[letter]\n\t}\n}\n\nfunc (trie ModifiedSuffixTrie) Contains(str string) bool {\n\tnode := trie\n\tfor i := range str {\n\t\tletter := str[i]\n\t\tif _, found := node[letter]; !found {\n\t\t\treturn false\n\t\t}\n\t\tnode = node[letter]\n\t}\n\treturn true\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\npackage main\n\n// O(ns + bs) time | O(ns) space\nfunc MultiStringSearch(bigString string, smallStrings []string) []bool {\n\ttrie := Trie{children: map[byte]Trie{}}\n\tfor _, str := range smallStrings {\n\t\ttrie.Add(str)\n\t}\n\tcontainedStrings := map[string]bool{}\n\tfor i := range bigString {\n\t\tfindSmallStringsIn(bigString, i, trie, containedStrings)\n\t}\n\toutput := make([]bool, len(smallStrings))\n\tfor i, str := range smallStrings {\n\t\toutput[i] = containedStrings[str]\n\t}\n\treturn output\n}\n\nfunc findSmallStringsIn(str string, startIdx int, trie Trie, containedStrings map[string]bool) {\n\tcurrent := trie\n\tfor i := startIdx; i < len(str); i++ {\n\t\tcurrentChar := str[i]\n\t\tif _, found := current.children[currentChar]; !found {\n\t\t\tbreak\n\t\t}\n\t\tcurrent = current.children[currentChar]\n\t\tif end, found := current.children['*']; found {\n\t\t\tcontainedStrings[end.word] = true\n\t\t}\n\t}\n}\n\ntype Trie struct {\n\tchildren map[byte]Trie\n\n\tword string\n}\n\nfunc (t Trie) Add(word string) {\n\tcurrent := t\n\tfor i := range word {\n\t\tletter := word[i]\n\t\tif _, found := current.children[letter]; !found {\n\t\t\tcurrent.children[letter] = Trie{\n\t\t\t\tchildren: map[byte]Trie{},\n\t\t\t}\n\t\t}\n\t\tcurrent = current.children[letter]\n\t}\n\tcurrent.children['*'] = Trie{\n\t\tchildren: map[byte]Trie{},\n\t\tword:     word,\n\t}\n}\n"
      ]
    },
    "java": {
      "Language": "java",
      "StartingCode": "import java.util.*;\n\nclass Program {\n  public static List<Boolean> multiStringSearch(String bigString, String[] smallStrings) {\n    // Write your code here.\n    return null;\n  }\n}\n",
      "StartingTest": "import java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    boolean[] expected = {true, false, true, true, false, true, false};\n    List<Boolean> output =\n        Program.multiStringSearch(\n            \"this is a big string\",\n            new String[] {\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"});\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  @Test\n  public void TestCase2() {\n    boolean[] expected = {true, true, false, true, true, false, false};\n    List<Boolean> output =\n        Program.multiStringSearch(\n            \"Mary goes to the shopping center every week.\",\n            new String[] {\"to\", \"Mary\", \"centers\", \"shop\", \"shopping\", \"string\", \"kappa\"});\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  @Test\n  public void TestCase3() {\n    boolean[] expected = {false, false, false, false, true, false, false};\n    List<Boolean> output =\n        Program.multiStringSearch(\n            \"adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda\",\n            new String[] {\"abcd\", \"acbd\", \"adbc\", \"dabc\", \"cbda\", \"cabd\", \"cdab\"});\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  @Test\n  public void TestCase4() {\n    boolean[] expected = {true, false, false, false, true, true};\n    List<Boolean> output =\n        Program.multiStringSearch(\n            \"test testing testings tests testers test-takers\",\n            new String[] {\"tests\", \"testatk\", \"testiing\", \"trsatii\", \"test-taker\", \"test\"});\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  @Test\n  public void TestCase5() {\n    boolean[] expected = {false, false, false, false, false, false, true};\n    List<Boolean> output =\n        Program.multiStringSearch(\n            \"ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd\",\n            new String[] {\"abc\", \"akwbc\", \"awbc\", \"abafac\", \"ajjfbc\", \"abac\", \"jadfl\"});\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  @Test\n  public void TestCase6() {\n    boolean[] expected = {false, true, false, false, false, false, false, true, true};\n    List<Boolean> output =\n        Program.multiStringSearch(\n            \"Is this particular test going to pass or is it going to fail? That is the question.\",\n            new String[] {\n              \"that\", \"the\", \"questions\", \"goes\", \"mountain\", \"passes\", \"passed\", \"going\", \"is\"\n            });\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  @Test\n  public void TestCase7() {\n    boolean[] expected = {false, false, false, false, false, false};\n    List<Boolean> output =\n        Program.multiStringSearch(\n            \"Everything in this test should fail.\",\n            new String[] {\"everything\", \"inn\", \"that\", \"testers\", \"shall\", \"failure\"});\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  public boolean compare(List<Boolean> arr1, boolean[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport java.util.*;\n\nclass ProgramTest {\n  @Test\n  public void TestCase1() {\n    boolean[] expected = {true, false, true, true, false, true, false};\n    List<Boolean> output =\n        Program.multiStringSearch(\n            \"this is a big string\",\n            new String[] {\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"});\n    Utils.assertTrue(compare(output, expected));\n  }\n\n  public boolean compare(List<Boolean> arr1, boolean[] arr2) {\n    if (arr1.size() != arr2.length) {\n      return false;\n    }\n    for (int i = 0; i < arr1.size(); i++) {\n      if (arr1.get(i) != arr2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(bns) time | O(n) space\n  public static List<Boolean> multiStringSearch(String bigString, String[] smallStrings) {\n    List<Boolean> solution = new ArrayList<Boolean>();\n    for (String smallString : smallStrings) {\n      solution.add(isInBigString(bigString, smallString));\n    }\n    return solution;\n  }\n\n  public static boolean isInBigString(String bigString, String smallString) {\n    for (int i = 0; i < bigString.length(); i++) {\n      if (i + smallString.length() > bigString.length()) {\n        break;\n      }\n      if (isInBigString(bigString, smallString, i)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public static boolean isInBigString(String bigString, String smallString, int startIdx) {\n    int leftBigIdx = startIdx;\n    int rightBigIdx = startIdx + smallString.length() - 1;\n    int leftSmallIdx = 0;\n    int rightSmallIdx = smallString.length() - 1;\n    while (leftBigIdx <= rightBigIdx) {\n      if (bigString.charAt(leftBigIdx) != smallString.charAt(leftSmallIdx)\n          || bigString.charAt(rightBigIdx) != smallString.charAt(rightSmallIdx)) {\n        return false;\n      }\n      leftBigIdx++;\n      rightBigIdx--;\n      leftSmallIdx++;\n      rightSmallIdx--;\n    }\n    return true;\n  }\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(b^2 + ns) time | O(b^2 + n) space\n  public static List<Boolean> multiStringSearch(String bigString, String[] smallStrings) {\n    ModifiedSuffixTrie modifiedSuffixTrie = new ModifiedSuffixTrie(bigString);\n    List<Boolean> solution = new ArrayList<Boolean>();\n    for (String smallString : smallStrings) {\n      solution.add(modifiedSuffixTrie.contains(smallString));\n    }\n    return solution;\n  }\n\n  static class TrieNode {\n    Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n  }\n\n  static class ModifiedSuffixTrie {\n    TrieNode root = new TrieNode();\n\n    public ModifiedSuffixTrie(String str) {\n      populateModifiedSuffixTrieFrom(str);\n    }\n\n    public void populateModifiedSuffixTrieFrom(String str) {\n      for (int i = 0; i < str.length(); i++) {\n        insertSubstringStartingAt(i, str);\n      }\n    }\n\n    public void insertSubstringStartingAt(int i, String str) {\n      TrieNode node = root;\n      for (int j = i; j < str.length(); j++) {\n        char letter = str.charAt(j);\n        if (!node.children.containsKey(letter)) {\n          TrieNode newNode = new TrieNode();\n          node.children.put(letter, newNode);\n        }\n        node = node.children.get(letter);\n      }\n    }\n\n    public boolean contains(String str) {\n      TrieNode node = root;\n      for (int i = 0; i < str.length(); i++) {\n        char letter = str.charAt(i);\n        if (!node.children.containsKey(letter)) {\n          return false;\n        }\n        node = node.children.get(letter);\n      }\n      return true;\n    }\n  }\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nimport java.util.*;\n\nclass Program {\n  // O(ns + bs) time | O(ns) space\n  public static List<Boolean> multiStringSearch(String bigString, String[] smallStrings) {\n    Trie trie = new Trie();\n    for (String smallString : smallStrings) {\n      trie.insert(smallString);\n    }\n    Set<String> containedStrings = new HashSet<String>();\n    for (int i = 0; i < bigString.length(); i++) {\n      findSmallStringsIn(bigString, i, trie, containedStrings);\n    }\n    List<Boolean> solution = new ArrayList<Boolean>();\n    for (String str : smallStrings) {\n      solution.add(containedStrings.contains(str));\n    }\n    return solution;\n  }\n\n  public static void findSmallStringsIn(\n      String str, int startIdx, Trie trie, Set<String> containedStrings) {\n    TrieNode currentNode = trie.root;\n    for (int i = startIdx; i < str.length(); i++) {\n      char currentChar = str.charAt(i);\n      if (!currentNode.children.containsKey(currentChar)) {\n        break;\n      }\n      currentNode = currentNode.children.get(currentChar);\n      if (currentNode.children.containsKey(trie.endSymbol)) {\n        containedStrings.add(currentNode.word);\n      }\n    }\n  }\n\n  static class TrieNode {\n    Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n    String word;\n  }\n\n  static class Trie {\n    TrieNode root = new TrieNode();\n    char endSymbol = '*';\n\n    public void insert(String str) {\n      TrieNode node = root;\n      for (int i = 0; i < str.length(); i++) {\n        char letter = str.charAt(i);\n        if (!node.children.containsKey(letter)) {\n          TrieNode newNode = new TrieNode();\n          node.children.put(letter, newNode);\n        }\n        node = node.children.get(letter);\n      }\n      node.children.put(endSymbol, null);\n      node.word = str;\n    }\n  }\n}\n"
      ]
    },
    "javascript": {
      "Language": "javascript",
      "StartingCode": "function multiStringSearch(bigString, smallStrings) {\n  // Write your code here.\n}\n\n// Do not edit the line below.\nexports.multiStringSearch = multiStringSearch;\n",
      "StartingTest": "const program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.multiStringSearch('this is a big string', ['this', 'yo', 'is', 'a', 'bigger', 'string', 'kappa']))\n    .to.deep.equal([true, false, true, true, false, true, false]);\n});\n\nit('Test Case #2', function () {\n  chai\n    .expect(\n      program.multiStringSearch('Mary goes to the shopping center every week.', [\n        'to',\n        'Mary',\n        'centers',\n        'shop',\n        'shopping',\n        'string',\n        'kappa',\n      ]),\n    )\n    .to.deep.equal([true, true, false, true, true, false, false]);\n});\n\nit('Test Case #3', function () {\n  chai\n    .expect(\n      program.multiStringSearch('adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda', [\n        'abcd',\n        'acbd',\n        'adbc',\n        'dabc',\n        'cbda',\n        'cabd',\n        'cdab',\n      ]),\n    )\n    .to.deep.equal([false, false, false, false, true, false, false]);\n});\n\nit('Test Case #4', function () {\n  chai\n    .expect(\n      program.multiStringSearch('test testing testings tests testers test-takers', [\n        'tests',\n        'testatk',\n        'testiing',\n        'trsatii',\n        'test-taker',\n        'test',\n      ]),\n    )\n    .to.deep.equal([true, false, false, false, true, true]);\n});\n\nit('Test Case #5', function () {\n  chai\n    .expect(\n      program.multiStringSearch('ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd', [\n        'abc',\n        'akwbc',\n        'awbc',\n        'abafac',\n        'ajjfbc',\n        'abac',\n        'jadfl',\n      ]),\n    )\n    .to.deep.equal([false, false, false, false, false, false, true]);\n});\n\nit('Test Case #6', function () {\n  chai\n    .expect(\n      program.multiStringSearch('Is this particular test going to pass or is it going to fail? That is the question.', [\n        'that',\n        'the',\n        'questions',\n        'goes',\n        'mountain',\n        'passes',\n        'passed',\n        'going',\n        'is',\n      ]),\n    )\n    .to.deep.equal([false, true, false, false, false, false, false, true, true]);\n});\n\nit('Test Case #7', function () {\n  chai\n    .expect(\n      program.multiStringSearch('Everything in this test should fail.', [\n        'everything',\n        'inn',\n        'that',\n        'testers',\n        'shall',\n        'failure',\n      ]),\n    )\n    .to.deep.equal([false, false, false, false, false, false]);\n});\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nconst program = require('./program');\nconst chai = require('chai');\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.multiStringSearch('this is a big string', ['this', 'yo', 'is', 'a', 'bigger', 'string', 'kappa']))\n    .to.deep.equal([true, false, true, true, false, true, false]);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n// O(bns) time | O(n) space\nfunction multiStringSearch(bigString, smallStrings) {\n  return smallStrings.map(smallString => isInBigString(bigString, smallString));\n}\n\nfunction isInBigString(bigString, smallString) {\n  for (let i = 0; i < bigString.length; i++) {\n    if (i + smallString.length > bigString.length) break;\n    if (isInBigStringHelper(bigString, smallString, i)) return true;\n  }\n  return false;\n}\n\nfunction isInBigStringHelper(bigString, smallString, startIdx) {\n  let leftBigIdx = startIdx;\n  let rightBigIdx = startIdx + smallString.length - 1;\n  let leftSmallIdx = 0;\n  let rightSmallIdx = smallString.length - 1;\n  while (leftBigIdx <= rightBigIdx) {\n    if (bigString[leftBigIdx] != smallString[leftSmallIdx] || bigString[rightBigIdx] != smallString[rightSmallIdx]) {\n      return false;\n    }\n    leftBigIdx++;\n    rightBigIdx--;\n    leftSmallIdx++;\n    rightSmallIdx--;\n  }\n  return true;\n}\n\nexports.multiStringSearch = multiStringSearch;\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n// O(b^2 + ns) time | O(b^2 + n) space\nfunction multiStringSearch(bigString, smallStrings) {\n  const modifiedSuffixTrie = new ModifiedSuffixTrie(bigString);\n  return smallStrings.map(string => modifiedSuffixTrie.contains(string));\n}\n\nclass ModifiedSuffixTrie {\n  constructor(string) {\n    this.root = {};\n    this.populateModifiedSuffixTrieFrom(string);\n  }\n\n  populateModifiedSuffixTrieFrom(string) {\n    for (let i = 0; i < string.length; i++) {\n      this.insertSubstringStartingAt(i, string);\n    }\n  }\n\n  insertSubstringStartingAt(i, string) {\n    let node = this.root;\n    for (let j = i; j < string.length; j++) {\n      const letter = string[j];\n      if (!(letter in node)) node[letter] = {};\n      node = node[letter];\n    }\n  }\n\n  contains(string) {\n    let node = this.root;\n    for (const letter of string) {\n      if (!(letter in node)) return false;\n      node = node[letter];\n    }\n    return true;\n  }\n}\n\nexports.multiStringSearch = multiStringSearch;\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n// O(ns + bs) time | O(ns) space\nfunction multiStringSearch(bigString, smallStrings) {\n  const trie = new Trie();\n  for (const string of smallStrings) {\n    trie.insert(string);\n  }\n  const containedStrings = {};\n  for (let i = 0; i < bigString.length; i++) {\n    findSmallStringsIn(bigString, i, trie, containedStrings);\n  }\n  return smallStrings.map(string => string in containedStrings);\n}\n\nfunction findSmallStringsIn(string, startIdx, trie, containedStrings) {\n  let currentNode = trie.root;\n  for (let i = startIdx; i < string.length; i++) {\n    const currentChar = string[i];\n    if (!(currentChar in currentNode)) break;\n    currentNode = currentNode[currentChar];\n    if (trie.endSymbol in currentNode) containedStrings[currentNode[trie.endSymbol]] = true;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = {};\n    this.endSymbol = '*';\n  }\n\n  insert(string) {\n    let current = this.root;\n    for (let i = 0; i < string.length; i++) {\n      if (!(string[i] in current)) {\n        current[string[i]] = {};\n      }\n      current = current[string[i]];\n    }\n    current[this.endSymbol] = string;\n  }\n}\n\nexports.multiStringSearch = multiStringSearch;\n"
      ]
    },
    "python": {
      "Language": "python",
      "StartingCode": "def multiStringSearch(bigString, smallStrings):\n    # Write your code here.\n    pass\n",
      "StartingTest": "import program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(\n            program.multiStringSearch(\"this is a big string\", [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]),\n            [True, False, True, True, False, True, False],\n        )\n\n    def test_case_2(self):\n        self.assertEqual(\n            program.multiStringSearch(\n                \"Mary goes to the shopping center every week.\",\n                [\"to\", \"Mary\", \"centers\", \"shop\", \"shopping\", \"string\", \"kappa\"],\n            ),\n            [True, True, False, True, True, False, False],\n        )\n\n    def test_case_3(self):\n        self.assertEqual(\n            program.multiStringSearch(\n                \"adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda\",\n                [\"abcd\", \"acbd\", \"adbc\", \"dabc\", \"cbda\", \"cabd\", \"cdab\"],\n            ),\n            [False, False, False, False, True, False, False],\n        )\n\n    def test_case_4(self):\n        self.assertEqual(\n            program.multiStringSearch(\n                \"test testing testings tests testers test-takers\",\n                [\"tests\", \"testatk\", \"testiing\", \"trsatii\", \"test-taker\", \"test\"],\n            ),\n            [True, False, False, False, True, True],\n        )\n\n    def test_case_5(self):\n        self.assertEqual(\n            program.multiStringSearch(\n                \"ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd\",\n                [\"abc\", \"akwbc\", \"awbc\", \"abafac\", \"ajjfbc\", \"abac\", \"jadfl\"],\n            ),\n            [False, False, False, False, False, False, True],\n        )\n\n    def test_case_6(self):\n        self.assertEqual(\n            program.multiStringSearch(\n                \"Is this particular test going to pass or is it going to fail? That is the question.\",\n                [\"that\", \"the\", \"questions\", \"goes\", \"mountain\", \"passes\", \"passed\", \"going\", \"is\"],\n            ),\n            [False, True, False, False, False, False, False, True, True],\n        )\n\n    def test_case_7(self):\n        self.assertEqual(\n            program.multiStringSearch(\n                \"Everything in this test should fail.\", [\"everything\", \"inn\", \"that\", \"testers\", \"shall\", \"failure\"]\n            ),\n            [False, False, False, False, False, False],\n        )\n",
      "SandboxCode": "# This file is initialized with a code version of this\n# question's sample test case. Feel free to add, edit,\n# or remove test cases in this file as you see fit!\n\nimport program\nimport unittest\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        self.assertEqual(\n            program.multiStringSearch(\"this is a big string\", [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]),\n            [True, False, True, True, False, True, False],\n        )\n",
      "Solutions": [
        "# Copyright © 2020 Code Complete. All rights reserved.\n\n# O(bns) time | O(n) space\ndef multiStringSearch(bigString, smallStrings):\n    return [isInBigString(bigString, smallString) for smallString in smallStrings]\n\n\ndef isInBigString(bigString, smallString):\n    for i in range(len(bigString)):\n        if i + len(smallString) > len(bigString):\n            break\n        if isInBigStringHelper(bigString, smallString, i):\n            return True\n    return False\n\n\ndef isInBigStringHelper(bigString, smallString, startIdx):\n    leftBigIdx = startIdx\n    rightBigIdx = startIdx + len(smallString) - 1\n    leftSmallIdx = 0\n    rightSmallIdx = len(smallString) - 1\n    while leftBigIdx <= rightBigIdx:\n        if bigString[leftBigIdx] != smallString[leftSmallIdx] or bigString[rightBigIdx] != smallString[rightSmallIdx]:\n            return False\n        leftBigIdx += 1\n        rightBigIdx -= 1\n        leftSmallIdx += 1\n        rightSmallIdx -= 1\n    return True\n",
        "# Copyright © 2020 Code Complete. All rights reserved.\n\n# O(b^2 + ns) time | O(b^2 + n) space\ndef multiStringSearch(bigString, smallStrings):\n    modifiedSuffixTrie = ModifiedSuffixTrie(bigString)\n    return [modifiedSuffixTrie.contains(string) for string in smallStrings]\n\n\nclass ModifiedSuffixTrie:\n    def __init__(self, string):\n        self.root = {}\n        self.populateModifiedSuffixTrieFrom(string)\n\n    def populateModifiedSuffixTrieFrom(self, string):\n        for i in range(len(string)):\n            self.insertSubstringStartingAt(i, string)\n\n    def insertSubstringStartingAt(self, i, string):\n        node = self.root\n        for j in range(i, len(string)):\n            letter = string[j]\n            if letter not in node:\n                node[letter] = {}\n            node = node[letter]\n\n    def contains(self, string):\n        node = self.root\n        for letter in string:\n            if letter not in node:\n                return False\n            node = node[letter]\n        return True\n",
        "# Copyright © 2020 Code Complete. All rights reserved.\n\n# O(ns + bs) time | O(ns) space\ndef multiStringSearch(bigString, smallStrings):\n    trie = Trie()\n    for string in smallStrings:\n        trie.insert(string)\n    containedStrings = {}\n    for i in range(len(bigString)):\n        findSmallStringsIn(bigString, i, trie, containedStrings)\n    return [string in containedStrings for string in smallStrings]\n\n\ndef findSmallStringsIn(string, startIdx, trie, containedStrings):\n    currentNode = trie.root\n    for i in range(startIdx, len(string)):\n        currentChar = string[i]\n        if currentChar not in currentNode:\n            break\n        currentNode = currentNode[currentChar]\n        if trie.endSymbol in currentNode:\n            containedStrings[currentNode[trie.endSymbol]] = True\n\n\nclass Trie:\n    def __init__(self):\n        self.root = {}\n        self.endSymbol = \"*\"\n\n    def insert(self, string):\n        current = self.root\n        for i in range(len(string)):\n            if string[i] not in current:\n                current[string[i]] = {}\n            current = current[string[i]]\n        current[self.endSymbol] = string\n"
      ]
    },
    "swift": {
      "Language": "swift",
      "StartingCode": "class Program {\n  func multiStringSearch(_ bigString: String, _ smallStrings: [String]) -> [Bool] {\n    // Write your code here.\n    return []\n  }\n}\n",
      "StartingTest": "class ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try assertEqual([true, false, true, true, false, true, false], program.multiStringSearch(\"this is a big string\", [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]))\n    }\n    runTest(\"Test Case 2\") { () throws -> Void in\n      try assertEqual([true, true, false, true, true, false, false], program.multiStringSearch(\"Mary goes to the shopping center every week.\", [\"to\", \"Mary\", \"centers\", \"shop\", \"shopping\", \"string\", \"kappa\"]))\n    }\n    runTest(\"Test Case 3\") { () throws -> Void in\n      try assertEqual([false, false, false, false, true, false, false], program.multiStringSearch(\"adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda\", [\"abcd\", \"acbd\", \"adbc\", \"dabc\", \"cbda\", \"cabd\", \"cdab\"]))\n    }\n    runTest(\"Test Case 4\") { () throws -> Void in\n      try assertEqual([true, false, false, false, true, true], program.multiStringSearch(\"test testing testings tests testers test-takers\", [\"tests\", \"testatk\", \"testiing\", \"trsatii\", \"test-taker\", \"test\"]))\n    }\n    runTest(\"Test Case 5\") { () throws -> Void in\n      try assertEqual([false, false, false, false, false, false, true], program.multiStringSearch(\"ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd\", [\"abc\", \"akwbc\", \"awbc\", \"abafac\", \"ajjfbc\", \"abac\", \"jadfl\"]))\n    }\n    runTest(\"Test Case 6\") { () throws -> Void in\n      try assertEqual([false, true, false, false, false, false, false, true, true], program.multiStringSearch(\"Is this particular test going to pass or is it going to fail? That is the question.\", [\"that\", \"the\", \"questions\", \"goes\", \"mountain\", \"passes\", \"passed\", \"going\", \"is\"]))\n    }\n    runTest(\"Test Case 7\") { () throws -> Void in\n      try assertEqual([false, false, false, false, false, false], program.multiStringSearch(\"Everything in this test should fail.\", [\"everything\", \"inn\", \"that\", \"testers\", \"shall\", \"failure\"]))\n    }\n  }\n}\n",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nclass ProgramTest: TestSuite {\n  func test() {\n    let program = Program()\n    runTest(\"Test Case 1\") { () throws -> Void in\n      try assertEqual([true, false, true, true, false, true, false], program.multiStringSearch(\"this is a big string\", [\"this\", \"yo\", \"is\", \"a\", \"bigger\", \"string\", \"kappa\"]))\n    }\n  }\n}\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Program {\n  // O(bns) time | O(n) space\n  func multiStringSearch(_ bigString: String, _ smallStrings: [String]) -> [Bool] {\n    return smallStrings.map { isInBigString($0, bigString) }\n  }\n\n  func isInBigString(_ smallString: String, _ bigString: String) -> Bool {\n    for i in 0 ..< bigString.count {\n      if i + smallString.count > bigString.count {\n        break\n      }\n\n      if isInBigStringHelper(i, smallString, bigString) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  func isInBigStringHelper(_ startIndex: Int, _ smallString: String, _ bigString: String) -> Bool {\n    var leftSmallIndex = 0\n    var rightSmallIndex = smallString.count - 1\n\n    var leftBigIndex = startIndex\n    var rightBigIndex = startIndex + smallString.count - 1\n\n    while leftBigIndex < rightBigIndex {\n      let leftSmallStringIndex = smallString.index(smallString.startIndex, offsetBy: leftSmallIndex)\n      let rightSmallStringIndex = smallString.index(smallString.startIndex, offsetBy: rightSmallIndex)\n\n      let leftBigStringIndex = bigString.index(bigString.startIndex, offsetBy: leftBigIndex)\n      let rightBigStringIndex = bigString.index(bigString.startIndex, offsetBy: rightBigIndex)\n\n      if smallString[leftSmallStringIndex] != bigString[leftBigStringIndex] || smallString[rightSmallStringIndex] != bigString[rightBigStringIndex] {\n        return false\n      }\n\n      leftSmallIndex += 1\n      rightSmallIndex -= 1\n      leftBigIndex += 1\n      rightBigIndex -= 1\n    }\n\n    return true\n  }\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Program {\n  // O(b ^ 2 + ns) time | O(b ^ 2 + n) space\n  func multiStringSearch(_ bigString: String, _ smallStrings: [String]) -> [Bool] {\n    let modifiedSuffixTrie = ModifiedSuffixTrie(string: bigString)\n\n    return smallStrings.map { modifiedSuffixTrie.contains($0) }\n  }\n\n  class TrieNode {\n    var children: [String: Any] = [:]\n  }\n\n  class ModifiedSuffixTrie {\n    var root = TrieNode()\n\n    init(string: String) {\n      populateModifiedSuffixTrieFrom(string)\n    }\n\n    func populateModifiedSuffixTrieFrom(_ string: String) {\n      for i in 0 ..< string.count {\n        insertSubstringStartingAt(i, string, root)\n      }\n    }\n\n    func insertSubstringStartingAt(_ index: Int, _ string: String, _ root: TrieNode) {\n      var node = root\n\n      for j in index ..< string.count {\n        let jStringIndex = string.index(string.startIndex, offsetBy: j)\n        let jthCharacter = String(string[jStringIndex])\n\n        if !node.children.keys.contains(jthCharacter) {\n          node.children[jthCharacter] = TrieNode()\n        }\n\n        let nextNode = node.children[jthCharacter] as! TrieNode\n        node = nextNode\n      }\n    }\n\n    func contains(_ string: String) -> Bool {\n      var node = root\n\n      for character in string {\n        let stringifiedCharacter = String(character)\n\n        if !node.children.keys.contains(stringifiedCharacter) {\n          return false\n        }\n\n        let nextNode = node.children[stringifiedCharacter] as! TrieNode\n        node = nextNode\n      }\n\n      return true\n    }\n  }\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\nclass Program {\n  class TrieNode {\n    var children: [String: Any] = [:]\n  }\n\n  class Trie {\n    var root = TrieNode()\n    let endSymbol = \"*\"\n\n    func insert(_ string: String) {\n      var node = root\n\n      for i in 0 ..< string.count {\n        let iStringIndex = string.index(string.startIndex, offsetBy: i)\n        let ithCharacter = String(string[iStringIndex])\n\n        if !node.children.keys.contains(ithCharacter) {\n          node.children[ithCharacter] = TrieNode()\n        }\n\n        let nextNode = node.children[ithCharacter] as! TrieNode\n        node = nextNode\n      }\n\n      node.children[endSymbol] = string\n    }\n  }\n\n  // O(ns + bs) time | O(ns) space\n  func multiStringSearch(_ bigString: String, _ smallStrings: [String]) -> [Bool] {\n    let trie = Trie()\n\n    for string in smallStrings {\n      trie.insert(string)\n    }\n\n    var containedStrings = [String: Bool]()\n\n    for i in 0 ..< bigString.count {\n      findSmallStringInBigString(bigString, i, trie, &containedStrings)\n    }\n\n    return smallStrings.map { containedStrings.keys.contains($0) }\n  }\n\n  func findSmallStringInBigString(_ string: String, _ startIndex: Int, _ trie: Trie, _ containedStrings: inout [String: Bool]) {\n    var currentNode = trie.root\n\n    for i in startIndex ..< string.count {\n      let currentStringIndex = string.index(string.startIndex, offsetBy: i)\n      let currentCharacter = String(string[currentStringIndex])\n\n      if !currentNode.children.keys.contains(currentCharacter) {\n        break\n      }\n\n      let nextNode = currentNode.children[currentCharacter] as! TrieNode\n      currentNode = nextNode\n\n      if currentNode.children.keys.contains(trie.endSymbol) {\n        let resultString = currentNode.children[trie.endSymbol] as! String\n        containedStrings[resultString] = true\n      }\n    }\n  }\n}\n"
      ]
    },
    "typescript": {
      "Language": "typescript",
      "StartingCode": "export function multiStringSearch(bigString: string, smallStrings: string[]) {\n  // Write your code here.\n  return [false];\n}\n",
      "StartingTest": "",
      "SandboxCode": "// This file is initialized with a code version of this\n// question's sample test case. Feel free to add, edit,\n// or remove test cases in this file as you see fit!\n\nimport * as program from './program';\nimport * as chai from 'chai';\n\nit('Test Case #1', function () {\n  chai\n    .expect(program.multiStringSearch('this is a big string', ['this', 'yo', 'is', 'a', 'bigger', 'string', 'kappa']))\n    .to.deep.equal([true, false, true, true, false, true, false]);\n});\n",
      "Solutions": [
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n// O(bns) time | O(n) space\nexport function multiStringSearch(bigString: string, smallStrings: string[]) {\n  return smallStrings.map(smallString => isInBigString(bigString, smallString));\n}\n\nfunction isInBigString(bigString: string, smallString: string) {\n  for (let i = 0; i < bigString.length; i++) {\n    if (i + smallString.length > bigString.length) break;\n    if (isInBigStringHelper(bigString, smallString, i)) return true;\n  }\n  return false;\n}\n\nfunction isInBigStringHelper(bigString: string, smallString: string, startIdx: number) {\n  let leftBigIdx = startIdx;\n  let rightBigIdx = startIdx + smallString.length - 1;\n  let leftSmallIdx = 0;\n  let rightSmallIdx = smallString.length - 1;\n  while (leftBigIdx <= rightBigIdx) {\n    if (bigString[leftBigIdx] != smallString[leftSmallIdx] || bigString[rightBigIdx] != smallString[rightSmallIdx]) {\n      return false;\n    }\n    leftBigIdx++;\n    rightBigIdx--;\n    leftSmallIdx++;\n    rightSmallIdx--;\n  }\n  return true;\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\n// O(b^2 + ns) time | O(b^2 + n) space\nexport function multiStringSearch(bigString: string, smallStrings: string[]) {\n  const modifiedSuffixTrie = new ModifiedSuffixTrie(bigString);\n  return smallStrings.map(string => modifiedSuffixTrie.contains(string));\n}\n\ninterface TrieNode {\n  [key: string]: TrieNode;\n}\n\nclass ModifiedSuffixTrie {\n  root: TrieNode;\n\n  constructor(string: string) {\n    this.root = {};\n    this.populateModifiedSuffixTrieFrom(string);\n  }\n\n  populateModifiedSuffixTrieFrom(string: string) {\n    for (let i = 0; i < string.length; i++) {\n      this.insertSubstringStartingAt(i, string);\n    }\n  }\n\n  insertSubstringStartingAt(i: number, string: string) {\n    let node = this.root;\n    for (let j = i; j < string.length; j++) {\n      const letter = string[j];\n      if (!(letter in node)) node[letter] = {};\n      node = node[letter];\n    }\n  }\n\n  contains(string: string) {\n    let node = this.root;\n    for (const letter of string) {\n      if (!(letter in node)) return false;\n      node = node[letter];\n    }\n    return true;\n  }\n}\n",
        "// Copyright © 2020 Code Complete. All rights reserved.\n\ninterface ContainedStrings {\n  [key: string]: boolean;\n}\n\n// O(ns + bs) time | O(ns) space\nexport function multiStringSearch(bigString: string, smallStrings: string[]) {\n  const trie = new Trie();\n  for (const string of smallStrings) {\n    trie.insert(string);\n  }\n  const containedStrings: ContainedStrings = {};\n  for (let i = 0; i < bigString.length; i++) {\n    findSmallStringsIn(bigString, i, trie, containedStrings);\n  }\n  return smallStrings.map(string => string in containedStrings);\n}\n\nfunction findSmallStringsIn(string: string, startIdx: number, trie: Trie, containedStrings: ContainedStrings) {\n  let currentNode = trie.root;\n  for (let i = startIdx; i < string.length; i++) {\n    const currentChar = string[i];\n    if (!(currentChar in currentNode)) break;\n    currentNode = currentNode[currentChar] as TrieNode;\n    if (trie.endSymbol in currentNode) containedStrings[currentNode[trie.endSymbol] as string] = true;\n  }\n}\n\ninterface TrieNode {\n  [key: string]: TrieNode | string;\n}\n\nclass Trie {\n  root: TrieNode;\n  endSymbol: string;\n\n  constructor() {\n    this.root = {};\n    this.endSymbol = '*';\n  }\n\n  insert(string: string) {\n    let current = this.root;\n    for (let i = 0; i < string.length; i++) {\n      if (!(string[i] in current)) {\n        current[string[i]] = {};\n      }\n      current = current[string[i]] as TrieNode;\n    }\n    current[this.endSymbol] = string;\n  }\n}\n"
      ]
    }
  },
  "JSONTestLanguages": [
    "javascript",
    "cpp",
    "python",
    "java",
    "csharp",
    "go",
    "swift",
    "typescript"
  ],
  "JSONTests": [
    {
      "bigString": "this is a big string",
      "smallStrings": [
        "this",
        "yo",
        "is",
        "a",
        "bigger",
        "string",
        "kappa"
      ]
    },
    {
      "bigString": "Mary goes to the shopping center every week.",
      "smallStrings": [
        "to",
        "Mary",
        "centers",
        "shop",
        "shopping",
        "string",
        "kappa"
      ]
    },
    {
      "bigString": "adcb akfkw afnmc fkadn vkaca jdaf dacb cdba cbda",
      "smallStrings": [
        "abcd",
        "acbd",
        "adbc",
        "dabc",
        "cbda",
        "cabd",
        "cdab"
      ]
    },
    {
      "bigString": "test testing testings tests testers test-takers",
      "smallStrings": [
        "tests",
        "testatk",
        "testiing",
        "trsatii",
        "test-taker",
        "test"
      ]
    },
    {
      "bigString": "ndbajwhfawkjljkfaopwdlaawjk dawkj awjkawkfjhkawk ahjwkjad jadfljawd",
      "smallStrings": [
        "abc",
        "akwbc",
        "awbc",
        "abafac",
        "ajjfbc",
        "abac",
        "jadfl"
      ]
    },
    {
      "bigString": "Is this particular test going to pass or is it going to fail? That is the question.",
      "smallStrings": [
        "that",
        "the",
        "questions",
        "goes",
        "mountain",
        "passes",
        "passed",
        "going",
        "is"
      ]
    },
    {
      "bigString": "Everything in this test should fail.",
      "smallStrings": [
        "everything",
        "inn",
        "that",
        "testers",
        "shall",
        "failure"
      ]
    }
  ],
  "JSONAnswers": [
    [
      [
        true,
        false,
        true,
        true,
        false,
        true,
        false
      ],
      [
        true,
        true,
        false,
        true,
        true,
        false,
        false
      ],
      [
        false,
        false,
        false,
        false,
        true,
        false,
        false
      ],
      [
        true,
        false,
        false,
        false,
        true,
        true
      ],
      [
        false,
        false,
        false,
        false,
        false,
        false,
        true
      ],
      [
        false,
        true,
        false,
        false,
        false,
        false,
        false,
        true,
        true
      ],
      [
        false,
        false,
        false,
        false,
        false,
        false
      ]
    ]
  ]
}